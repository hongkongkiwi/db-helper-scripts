#!/bin/bash

# Database User Management Script
# Supports PostgreSQL user creation, password management, and permission granting

set -euo pipefail

# Script configuration
SCRIPT_NAME=$(basename "$0")
SCRIPT_VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
VERBOSE=false
QUIET=false
FORCE=false
DRY_RUN=false

# Connection parameters
DB_HOST=""
DB_PORT=""
DB_USER=""
DB_NAME=""
DB_PASSWORD=""
PASSWD_STDIN=false
DATABASE_URL=""

# SSL Options
SSL_MODE=""
SSL_CERT=""
SSL_KEY=""
SSL_CA=""

# Exit codes
EXIT_SUCCESS=0
EXIT_GENERAL_ERROR=1
EXIT_CONNECTION_ERROR=2
EXIT_USER_EXISTS_ERROR=3
EXIT_USER_NOT_EXISTS_ERROR=4
EXIT_PERMISSION_ERROR=5

# Input validation and security functions
sanitize_for_log() {
    local input="$1"
    echo "$input" | sed -E 's/(password|passwd|pass)[[:space:]]*[:=][[:space:]]*[^[:space:]&]+/\1=***REDACTED***/gi' | \
                    sed -E 's/postgresql:\/\/[^:]*:[^@]*@/postgresql:\/\/user:***@/g'
}

sanitize_string() {
    local input="$1"
    echo "$input" | tr -d '`;|&$(){}[]<>*?~^!"'"'"
}

validate_username() {
    local username="$1"
    if [[ ! "$username" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]] || [[ ${#username} -gt 63 ]]; then
        log_error "Invalid username: $username (must start with letter/underscore, contain only alphanumeric/underscore, max 63 chars)"
        exit $EXIT_GENERAL_ERROR
    fi
}

validate_db_name() {
    local db_name="$1"
    if [[ ! "$db_name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]] || [[ ${#db_name} -gt 63 ]]; then
        log_error "Invalid database name: $db_name (must start with letter/underscore, contain only alphanumeric/underscore, max 63 chars)"
        exit $EXIT_GENERAL_ERROR
    fi
}

validate_numeric() {
    local value="$1"
    local name="$2"
    local min="${3:-0}"
    local max="${4:-999999}"

    if ! [[ "$value" =~ ^[0-9]+$ ]]; then
        log_error "Invalid numeric value for $name: $value (must be a number)"
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ $value -lt $min ]] || [[ $value -gt $max ]]; then
        log_error "Value out of range for $name: $value (must be between $min and $max)"
        exit $EXIT_GENERAL_ERROR
    fi
}

# Logging functions
log_info() {
    local message="$1"
    local safe_message=$(sanitize_for_log "$message")
    if [[ "$QUIET" != "true" ]]; then
        echo -e "${BLUE}[INFO]${NC} $safe_message" >&2
    fi
}

log_success() {
    local message="$1"
    local safe_message=$(sanitize_for_log "$message")
    if [[ "$QUIET" != "true" ]]; then
        echo -e "${GREEN}[SUCCESS]${NC} $safe_message" >&2
    fi
}

log_warning() {
    local message="$1"
    local safe_message=$(sanitize_for_log "$message")
    if [[ "$QUIET" != "true" ]]; then
        echo -e "${YELLOW}[WARNING]${NC} $safe_message" >&2
    fi
}

log_error() {
    local message="$1"
    local safe_message=$(sanitize_for_log "$message")
    echo -e "${RED}[ERROR]${NC} $safe_message" >&2
}

log_verbose() {
    local message="$1"
    local safe_message=$(sanitize_for_log "$message")
    if [[ "$VERBOSE" == "true" && "$QUIET" != "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $safe_message" >&2
    fi
}

# Help functions
show_help() {
    cat << EOF
$SCRIPT_NAME v$SCRIPT_VERSION - PostgreSQL Database User Management Tool

USAGE:
    $SCRIPT_NAME <command> [options]

COMMANDS:
    create-user         Create a new database user
    change-password     Change user password
    delete-user         Delete a database user
    grant-db-access     Grant user access to specific database
    grant-schema-access Grant user access to specific schema
    grant-table-access  Grant user access to specific tables
    grant-function-access Grant user access to functions/procedures
    grant-view-access   Grant user access to views
    grant-column-access Grant user access to specific columns
    grant-create-db     Grant user permission to create databases
    grant-sequence-access Grant user access to sequences
    grant-tablespace-access Grant user access to tablespaces
    revoke-access       Revoke user permissions
    revoke-table-access Revoke user table permissions
    show-user-permissions Show detailed permissions for a user
    copy-user-permissions Copy permissions from one user to another
    clone-user-permissions Clone user permissions between databases
    lock-user           Disable user login
    unlock-user         Enable user login
    reset-user          Reset user (revoke all permissions)
    set-connection-limit Set connection limit for user
    rotate-password     Rotate user password with auto-generation
    set-password-policy Configure password policies
    create-role         Create a database role
    assign-role         Assign role to user
    revoke-role         Revoke role from user
    list-roles          List database roles
    list-user-roles     List roles for specific user
    list-role-members   List users who have specific role
    enable-rls          Enable row-level security on table
    disable-rls         Disable row-level security on table
    create-policy       Create row-level security policy
    list-users          List database users and their permissions
    show-active-connections Show active database connections
    terminate-user-connections Terminate all connections for a user
    show-user-activity  Show recent user activity
    security-scan       Scan for security issues
    audit-permissions   Generate comprehensive permissions report
    validate-permissions Validate user has minimum required permissions
    backup-permissions  Export user permissions to file
    restore-permissions Import user permissions from file
    create-users-batch  Create multiple users from file
    bulk-grant          Grant permissions to multiple users
    apply-template      Apply user template to users
    save-config         Save connection settings to file
    load-config         Load connection settings from file
    help                Show this help message
    version             Show version information

GLOBAL OPTIONS:
    -v, --verbose     Enable verbose output
    -q, --quiet       Suppress all output except errors
    --dry-run         Show what would be done without executing
    -h, --help        Show help message

CONNECTION OPTIONS:
    -H, --host <host>        Database host (default: localhost)
    -p, --port <port>        Database port (default: 5432)
    -U, --username <user>    Database username (admin user)
    -d, --dbname <name>      Database name
    --passwd-stdin           Read password from stdin

SSL OPTIONS:
    --ssl-mode <mode>        SSL connection mode (default: prefer)
    --ssl-cert <path>        SSL client certificate file path
    --ssl-key <path>         SSL client private key file path
    --ssl-ca <path>          SSL certificate authority (CA) file path

For command-specific help, use: $SCRIPT_NAME <command> --help

EXAMPLES:
    # Create a new user
    $SCRIPT_NAME create-user -H localhost -U postgres --new-user myapp_user

    # Grant database access
    $SCRIPT_NAME grant-db-access -U postgres --target-user myapp_user --target-db myapp

    # List all users
    $SCRIPT_NAME list-users -H localhost -U postgres

EOF
}

show_create_user_help() {
    cat << EOF
$SCRIPT_NAME create-user - Create a new database user

USAGE:
    $SCRIPT_NAME create-user --new-user <username> [options]

REQUIRED OPTIONS:
    --new-user <name>        Name of the user to create

OPTIONS:
    --new-password <pass>    Password for new user (prompted if not provided)
    --superuser              Create user with superuser privileges
    --createdb               Allow user to create databases
    --createrole             Allow user to create roles
    --login                  Allow user to login (default: true)
    --connection-limit <num> Connection limit for user (default: unlimited)
    --force                  Force creation even if user exists
    --help                   Show this help message

EXAMPLES:
    # Create basic user with prompted password
    $SCRIPT_NAME create-user -U postgres --new-user myapp_user

    # Create user with specific password and database creation privileges
    echo "mypassword" | $SCRIPT_NAME create-user --passwd-stdin -U postgres --new-user myapp_user --createdb # pragma: allowlist secret

    # Create superuser
    $SCRIPT_NAME create-user -U postgres --new-user admin_user --superuser

EOF
}

show_grant_db_access_help() {
    cat << EOF
$SCRIPT_NAME grant-db-access - Grant user access to database

USAGE:
    $SCRIPT_NAME grant-db-access --target-user <username> --target-db <database> [options]

REQUIRED OPTIONS:
    --target-user <name>     Username to grant access to
    --target-db <name>       Database name to grant access to

OPTIONS:
    --privileges <privs>     Comma-separated privileges (default: CONNECT,CREATE)
                            Valid: CONNECT,CREATE,TEMPORARY,TEMP,ALL
    --schema <name>         Grant privileges on specific schema (default: public)
    --table-privileges <privs> Table-level privileges (SELECT,INSERT,UPDATE,DELETE,ALL)
    --grant-all-tables      Grant table privileges on all existing tables
    --grant-default-privs   Grant default privileges for future tables
    --help                  Show this help message

EXAMPLES:
    # Grant basic database access
    $SCRIPT_NAME grant-db-access -U postgres --target-user myapp_user --target-db myapp

    # Grant full access including all tables
    $SCRIPT_NAME grant-db-access -U postgres --target-user myapp_user --target-db myapp --privileges ALL --grant-all-tables

    # Grant read-only access
    $SCRIPT_NAME grant-db-access -U postgres --target-user readonly_user --target-db myapp --table-privileges SELECT

EOF
}

show_change_password_help() {
    cat << EOF
$SCRIPT_NAME change-password - Change user password

USAGE:
    $SCRIPT_NAME change-password --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <name>     Username to change password for

OPTIONS:
    --new-password <pass>    New password (prompted if not provided)
    --help                   Show this help message

EXAMPLES:
    # Change password with prompt
    $SCRIPT_NAME change-password -U postgres --target-user myapp_user

    # Change password from stdin
    echo "newpassword" | $SCRIPT_NAME change-password --passwd-stdin -U postgres --target-user myapp_user --new-password newpassword # pragma: allowlist secret

EOF
}

show_delete_user_help() {
    cat << EOF
$SCRIPT_NAME delete-user - Delete a database user

USAGE:
    $SCRIPT_NAME delete-user --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <name>     Username to delete

OPTIONS:
    --reassign-to <user>     Reassign owned objects to another user
    --drop-owned             Drop all objects owned by the user
    --terminate-connections  Terminate active connections before deletion
    --force                  Force deletion without confirmation
    --help                   Show this help message

EXAMPLES:
    # Delete user with confirmation
    $SCRIPT_NAME delete-user -U postgres --target-user old_user

    # Force delete and reassign objects
    $SCRIPT_NAME delete-user -U postgres --target-user old_user --reassign-to new_user --force

EOF
}

show_revoke_access_help() {
    cat << EOF
$SCRIPT_NAME revoke-access - Revoke user permissions

USAGE:
    $SCRIPT_NAME revoke-access --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <name>     Username to revoke access from

OPTIONS:
    --target-db <name>       Database to revoke access from
    --privileges <privs>     Privileges to revoke (default: ALL)
    --schema <name>          Schema to revoke access from
    --table-privileges <privs> Table privileges to revoke
    --revoke-all-tables      Revoke privileges on all tables
    --help                   Show this help message

EXAMPLES:
    # Revoke database access
    $SCRIPT_NAME revoke-access -U postgres --target-user old_user --target-db myapp

    # Revoke specific table privileges
    $SCRIPT_NAME revoke-access -U postgres --target-user temp_user --target-db myapp --table-privileges SELECT,INSERT

EOF
}

show_show_user_permissions_help() {
    cat << EOF
$SCRIPT_NAME show-user-permissions - Show detailed user permissions

USAGE:
    $SCRIPT_NAME show-user-permissions --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <name>     Username to show permissions for

OPTIONS:
    --target-db <name>       Show permissions for specific database only
    --format <format>        Output format: table, json (default: table)
    --help                   Show this help message

EXAMPLES:
    # Show all permissions for user
    $SCRIPT_NAME show-user-permissions -U postgres --target-user myapp_user

    # Show permissions for specific database in JSON
    $SCRIPT_NAME show-user-permissions -U postgres --target-user myapp_user --target-db myapp --format json

EOF
}

# Database connection functions
extract_password_from_url() {
    if [[ -n "${DATABASE_URL:-}" ]]; then
        if [[ "$DATABASE_URL" =~ postgresql://[^:]+:([^@]+)@ ]]; then
            local extracted_password="${BASH_REMATCH[1]}"
            log_verbose "Password extracted from DATABASE_URL"
            export PGPASSWORD="$extracted_password"
            return 0
        fi
    fi
    return 1
}

handle_password() {
    if extract_password_from_url; then
        log_verbose "Using password from DATABASE_URL"
        return 0
    fi

    if [[ "$PASSWD_STDIN" == "true" ]]; then
        if [[ -t 0 ]]; then
            log_error "No password provided via stdin. Use: echo 'password' | $SCRIPT_NAME ..." # pragma: allowlist secret
            exit $EXIT_GENERAL_ERROR
        fi
        DB_PASSWORD=$(cat)
        log_verbose "Password read from stdin"
    elif [[ -z "${PGPASSWORD:-}" && -z "$DB_PASSWORD" ]]; then
        if [[ -t 0 ]]; then
            echo -n "Enter database password: " >&2  # pragma: allowlist secret
            read -s DB_PASSWORD
            echo >&2
            log_verbose "Password read interactively"
        fi
    fi

    if [[ -n "$DB_PASSWORD" ]]; then
        export PGPASSWORD="$DB_PASSWORD"
    fi
}

build_connection_string() {
    if [[ -n "$DATABASE_URL" ]]; then
        echo "$DATABASE_URL"
        return 0
    fi

    local connection_string="postgresql://"

    if [[ -n "$DB_USER" ]]; then
        connection_string="${connection_string}${DB_USER}"
        if [[ -n "$DB_PASSWORD" ]]; then
            connection_string="${connection_string}:${DB_PASSWORD}"
        fi
        connection_string="${connection_string}@"
    fi

    connection_string="${connection_string}${DB_HOST:-localhost}"

    if [[ -n "$DB_PORT" ]]; then
        connection_string="${connection_string}:${DB_PORT}"
    fi

    if [[ -n "$DB_NAME" ]]; then
        connection_string="${connection_string}/${DB_NAME}"
    fi

    echo "$connection_string"
}

get_database_url() {
    if [[ -n "${DATABASE_URL:-}" ]]; then
        log_verbose "Using DATABASE_URL from environment variable"
        return 0
    fi

    if [[ ! -t 0 && "$PASSWD_STDIN" != "true" ]]; then
        DATABASE_URL=$(cat)
        if [[ -n "$DATABASE_URL" ]]; then
            log_verbose "Using DATABASE_URL from stdin"
            return 0
        fi
    fi

    if [[ -n "$DB_HOST" || -n "$DB_USER" ]]; then
        DATABASE_URL=$(build_connection_string)
        log_verbose "Built DATABASE_URL from individual parameters"
        return 0
    fi

    log_error "No database connection information provided."
    log_error "Use individual parameters: -H host -p port -U user [-d dbname]"
    exit $EXIT_GENERAL_ERROR
}

setup_ssl_environment() {
    if [[ -n "$SSL_MODE" ]]; then
        export PGSSLMODE="$SSL_MODE"
        log_verbose "Set PGSSLMODE=$SSL_MODE"
    fi
    if [[ -n "$SSL_CERT" ]]; then
        export PGSSLCERT="$SSL_CERT"
        log_verbose "Set PGSSLCERT=$SSL_CERT"
    fi
    if [[ -n "$SSL_KEY" ]]; then
        export PGSSLKEY="$SSL_KEY"
        log_verbose "Set PGSSLKEY=$SSL_KEY"
    fi
    if [[ -n "$SSL_CA" ]]; then
        export PGSSLROOTCERT="$SSL_CA"
        log_verbose "Set PGSSLROOTCERT=$SSL_CA"
    fi
}

test_database_connection() {
    log_verbose "Testing database connection..."
    if psql "$DATABASE_URL" -c '\q' &>/dev/null; then
        log_verbose "Database connection test successful"
        return 0
    else
        log_error "Database connection test failed"
        exit $EXIT_CONNECTION_ERROR
    fi
}

# Utility functions
execute_sql_query() {
    local sql="$1"
    local description="${2:-SQL query}"

    log_verbose "Executing query: $description"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would execute: $sql"
        return 0
    fi

    psql "$DATABASE_URL" -c "$sql" 2>/dev/null
}

execute_sql_file() {
    local file_path="$1"
    local description="${2:-SQL file}"

    log_verbose "Executing SQL file: $file_path"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would execute SQL file: $file_path"
        return 0
    fi

    psql "$DATABASE_URL" -f "$file_path" &>/dev/null
}

execute_sql() {
    local sql="$1"
    local description="${2:-SQL command}"

    log_verbose "Executing: $description"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would execute: $sql"
        return 0
    fi

    if psql "$DATABASE_URL" -c "$sql" &>/dev/null; then
        log_verbose "SQL execution successful"
        return 0
    else
        log_error "SQL execution failed: $description"
        return 1
    fi
}

execute_sql_with_output() {
    local sql="$1"
    local description="${2:-SQL query}"

    log_verbose "Executing query: $description"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would execute: $sql"
        echo ""
        return 0
    fi

    psql "$DATABASE_URL" -t -c "$sql" 2>/dev/null | xargs
}

user_exists() {
    local username="$1"
    local count=$(execute_sql_with_output "SELECT COUNT(*) FROM pg_roles WHERE rolname = '$username';" "Check if user exists")
    [[ "$count" -gt 0 ]]
}

database_exists() {
    local dbname="$1"
    local count=$(execute_sql_with_output "SELECT COUNT(*) FROM pg_database WHERE datname = '$dbname';" "Check if database exists")
    [[ "$count" -gt 0 ]]
}

# Common argument parsing functions
parse_connection_arguments() {
    local key="$1"
    local value="$2"

    case "$key" in
        -H|--host)
            DB_HOST=$(sanitize_string "$value")
            echo "2"
            ;;
        -p|--port)
            validate_numeric "$value" "port" 1 65535
            DB_PORT="$value"
            echo "2"
            ;;
        -U|--username)
            DB_USER=$(sanitize_string "$value")
            echo "2"
            ;;
        -d|--dbname)
            validate_db_name "$value"
            DB_NAME="$value"
            echo "2"
            ;;
        --passwd-stdin)
            PASSWD_STDIN=true
            echo "1"
            ;;
        *)
            echo "0"
            return 1
            ;;
    esac
    return 0
}

parse_ssl_arguments() {
    local key="$1"
    local value="$2"

    case "$key" in
        --ssl-mode)
            SSL_MODE="$value"
            echo "2"
            ;;
        --ssl-cert)
            SSL_CERT="$value"
            echo "2"
            ;;
        --ssl-key)
            SSL_KEY="$value"
            echo "2"
            ;;
        --ssl-ca)
            SSL_CA="$value"
            echo "2"
            ;;
        *)
            echo "0"
            return 1
            ;;
    esac
    return 0
}

# Extract and process global options from arguments
extract_global_options() {
    local -a new_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            *)
                new_args+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#new_args[@]} -gt 0 ]]; then
        FILTERED_ARGS=("${new_args[@]}")
    else
        FILTERED_ARGS=()
    fi
}

# Command implementations
cmd_create_user() {
    local new_user=""
    local new_password=""
    local superuser=false
    local createdb=false
    local createrole=false
    local login=true
    local connection_limit=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --new-user)
                validate_username "$2"
                new_user="$2"
                shift 2
                ;;
            --new-password)
                new_password="$2"
                shift 2
                ;;
            --superuser)
                superuser=true
                shift
                ;;
            --createdb)
                createdb=true
                shift
                ;;
            --createrole)
                createrole=true
                shift
                ;;
            --nologin)
                login=false
                shift
                ;;
            --connection-limit)
                validate_numeric "$2" "connection-limit" -1 1000
                connection_limit="$2"
                shift 2
                ;;
            --help)
                show_create_user_help
                exit 0
                ;;
            *)
                log_error "Unknown create-user option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$new_user" ]]; then
        log_error "New username is required. Use --new-user option."
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Critical validation: Prevent creating PostgreSQL reserved users
    local reserved_users=("postgres" "template0" "template1" "replication" "rds_superuser" "rds_replication" "root" "admin" "public")
    for reserved in "${reserved_users[@]}"; do
        if [[ "$new_user" == "$reserved" ]]; then
            log_error "Cannot create user with reserved name: $new_user"
            log_error "Reserved user names: ${reserved_users[*]}"
            exit $EXIT_GENERAL_ERROR
        fi
    done
    
    # Validate password strength if provided
    if [[ -n "$new_password" ]]; then
        if [[ ${#new_password} -lt 8 ]]; then
            log_warning "Password is shorter than 8 characters. Consider using a stronger password."
        fi
        
        if [[ "$new_password" =~ ^[a-z]*$ ]] || [[ "$new_password" =~ ^[A-Z]*$ ]] || [[ "$new_password" =~ ^[0-9]*$ ]]; then
            log_warning "Password contains only one character type. Consider using mixed case, numbers, and symbols."
        fi
    fi
    
    # Validate combination of privileges
    if [[ "$superuser" == "true" ]]; then
        log_warning "Granting SUPERUSER privilege. This user will have full administrative access."
        if [[ "$FORCE" != "true" ]]; then
            read -p "Are you sure you want to create a superuser? (y/N): " -r
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "User creation cancelled"
                exit $EXIT_SUCCESS
            fi
        fi
    fi
    
    if [[ "$login" == "false" && "$connection_limit" != "-1" ]]; then
        log_warning "Connection limit specified for non-login user (will be ignored)"
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if user_exists "$new_user"; then
        if [[ "$FORCE" == "true" ]]; then
            log_warning "User '$new_user' already exists, but --force specified"
        else
            log_error "User '$new_user' already exists. Use --force to recreate."
            exit $EXIT_USER_EXISTS_ERROR
        fi
    fi

    if [[ -z "$new_password" ]]; then
        echo -n "Enter password for new user '$new_user': " >&2  # pragma: allowlist secret
        read -s new_password
        echo >&2
        if [[ -z "$new_password" ]]; then
            log_error "Password cannot be empty"
            exit $EXIT_GENERAL_ERROR
        fi
    fi

    # Build CREATE USER command
    local create_sql="CREATE USER \"$new_user\" WITH PASSWORD '$new_password'" # pragma: allowlist secret

    if [[ "$superuser" == "true" ]]; then
        create_sql="$create_sql SUPERUSER"
    else
        create_sql="$create_sql NOSUPERUSER"
    fi

    if [[ "$createdb" == "true" ]]; then
        create_sql="$create_sql CREATEDB"
    else
        create_sql="$create_sql NOCREATEDB"
    fi

    if [[ "$createrole" == "true" ]]; then
        create_sql="$create_sql CREATEROLE"
    else
        create_sql="$create_sql NOCREATEROLE"
    fi

    if [[ "$login" == "true" ]]; then
        create_sql="$create_sql LOGIN"
    else
        create_sql="$create_sql NOLOGIN"
    fi

    if [[ -n "$connection_limit" ]]; then
        create_sql="$create_sql CONNECTION LIMIT $connection_limit"
    fi

    create_sql="$create_sql;"

    log_info "Creating user: $new_user"

    if [[ "$FORCE" == "true" ]] && user_exists "$new_user"; then
        if execute_sql "DROP USER IF EXISTS \"$new_user\";" "Drop existing user"; then
            log_verbose "Existing user dropped"
        fi
    fi

    if execute_sql "$create_sql" "Create new user"; then
        log_success "User '$new_user' created successfully"

        # Log user privileges
        if [[ "$VERBOSE" == "true" ]]; then
            log_info "User privileges:"
            [[ "$superuser" == "true" ]] && log_info "  → Superuser"
            [[ "$createdb" == "true" ]] && log_info "  → Can create databases"
            [[ "$createrole" == "true" ]] && log_info "  → Can create roles"
            [[ "$login" == "true" ]] && log_info "  → Can login"
            [[ -n "$connection_limit" ]] && log_info "  → Connection limit: $connection_limit"
        fi
    else
        log_error "Failed to create user '$new_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_grant_db_access() {
    local target_user=""
    local target_db=""
    local privileges="CONNECT,CREATE"
    local schema="public"
    local table_privileges=""
    local grant_all_tables=false
    local grant_default_privs=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --table-privileges)
                table_privileges="$2"
                shift 2
                ;;
            --grant-all-tables)
                grant_all_tables=true
                shift
                ;;
            --grant-default-privs)
                grant_default_privs=true
                shift
                ;;
            --help)
                show_grant_db_access_help
                exit 0
                ;;
            *)
                log_error "Unknown grant-db-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_db" ]]; then
        log_error "Target database is required. Use --target-db option."
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Critical validation: Prevent self-granting permissions
    if [[ "$target_user" == "$DB_USER" ]]; then
        log_warning "You are granting permissions to yourself ($target_user)"
        if [[ "$FORCE" != "true" ]]; then
            read -p "Are you sure you want to grant permissions to yourself? (y/N): " -r
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "Permission grant cancelled"
                exit $EXIT_SUCCESS
            fi
        fi
    fi
    
    # Validate privilege combinations
    if [[ "$privileges" == *"ALL"* ]]; then
        log_warning "Granting ALL privileges on database. This includes administrative access."
        if [[ "$FORCE" != "true" ]]; then
            read -p "Are you sure you want to grant ALL privileges? (y/N): " -r
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log_info "Permission grant cancelled"
                exit $EXIT_SUCCESS
            fi
        fi
    fi
    
    # Check for duplicate database connections
    if [[ "$target_db" == "$DB_NAME" ]]; then
        log_verbose "Granting permissions on the same database we're connected to"
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! database_exists "$target_db"; then
        log_error "Database '$target_db' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Granting database access to user: $target_user"
    log_info "Database: $target_db"
    log_info "Privileges: $privileges"

    # Grant database privileges
    if execute_sql "GRANT $privileges ON DATABASE \"$target_db\" TO \"$target_user\";" "Grant database privileges"; then
        log_success "Database privileges granted successfully"
    else
        log_error "Failed to grant database privileges"
        exit $EXIT_PERMISSION_ERROR
    fi

    # Grant schema privileges if specified
    if [[ -n "$schema" && "$schema" != "public" ]]; then
        if execute_sql "GRANT USAGE ON SCHEMA \"$schema\" TO \"$target_user\";" "Grant schema usage"; then
            log_success "Schema usage granted on: $schema"
        fi
    fi

    # Grant table privileges if specified
    if [[ -n "$table_privileges" ]]; then
        local table_db_url=$(echo "$DATABASE_URL" | sed "s|/[^/]*$|/$target_db|")

        if [[ "$grant_all_tables" == "true" ]]; then
            if PGPASSWORD="${PGPASSWORD:-}" psql "$table_db_url" -c "GRANT $table_privileges ON ALL TABLES IN SCHEMA \"$schema\" TO \"$target_user\";" &>/dev/null; then
                log_success "Table privileges granted on all existing tables"
            fi
        fi

        if [[ "$grant_default_privs" == "true" ]]; then
            if PGPASSWORD="${PGPASSWORD:-}" psql "$table_db_url" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA \"$schema\" GRANT $table_privileges ON TABLES TO \"$target_user\";" &>/dev/null; then
                log_success "Default table privileges granted for future tables"
            fi
        fi
    fi

    log_success "Access granted successfully to user '$target_user' on database '$target_db'"
}

cmd_list_users() {
    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --help)
                echo "Usage: $SCRIPT_NAME list-users [connection-options]"
                exit 0
                ;;
            *)
                log_error "Unknown list-users option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Listing database users and their privileges:"
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would list users from database"
        return 0
    fi

    printf "%-20s %-10s %-10s %-10s %-10s %-15s\n" "USERNAME" "SUPERUSER" "CREATEDB" "CREATEROLE" "LOGIN" "CONN_LIMIT"
    printf "%-20s %-10s %-10s %-10s %-10s %-15s\n" "$(printf '%*s' 20 | tr ' ' '-')" "$(printf '%*s' 10 | tr ' ' '-')" "$(printf '%*s' 10 | tr ' ' '-')" "$(printf '%*s' 10 | tr ' ' '-')" "$(printf '%*s' 10 | tr ' ' '-')" "$(printf '%*s' 15 | tr ' ' '-')"

    psql "$DATABASE_URL" -t -c "
        SELECT
            rolname,
            CASE WHEN rolsuper THEN 'YES' ELSE 'NO' END,
            CASE WHEN rolcreatedb THEN 'YES' ELSE 'NO' END,
            CASE WHEN rolcreaterole THEN 'YES' ELSE 'NO' END,
            CASE WHEN rolcanlogin THEN 'YES' ELSE 'NO' END,
            CASE WHEN rolconnlimit = -1 THEN 'unlimited' ELSE rolconnlimit::text END
        FROM pg_roles
        WHERE rolname NOT LIKE 'pg_%'
        ORDER BY rolname;
    " | while IFS='|' read -r username superuser createdb createrole login connlimit; do
        printf "%-20s %-10s %-10s %-10s %-10s %-15s\n" \
            "$(echo "$username" | xargs)" \
            "$(echo "$superuser" | xargs)" \
            "$(echo "$createdb" | xargs)" \
            "$(echo "$createrole" | xargs)" \
            "$(echo "$login" | xargs)" \
            "$(echo "$connlimit" | xargs)"
    done
}

cmd_change_password() {
    local target_user=""
    local new_password=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --new-password)
                new_password="$2"
                shift 2
                ;;
            --help)
                show_change_password_help
                exit 0
                ;;
            *)
                log_error "Unknown change-password option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if [[ -z "$new_password" ]]; then
        echo -n "Enter new password for user '$target_user': " >&2  # pragma: allowlist secret
        read -s new_password
        echo >&2
        if [[ -z "$new_password" ]]; then
            log_error "Password cannot be empty"
            exit $EXIT_GENERAL_ERROR
        fi
    fi

    log_info "Changing password for user: $target_user"

    if execute_sql "ALTER USER \"$target_user\" WITH PASSWORD '$new_password';" "Change user password"; then # pragma: allowlist secret
        log_success "Password changed successfully for user '$target_user'"
    else
        log_error "Failed to change password for user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_delete_user() {
    local target_user=""
    local reassign_to=""
    local drop_owned=false
    local terminate_connections=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --reassign-to)
                validate_username "$2"
                reassign_to="$2"
                shift 2
                ;;
            --drop-owned)
                drop_owned=true
                shift
                ;;
            --terminate-connections)
                terminate_connections=true
                shift
                ;;
            --help)
                show_delete_user_help
                exit 0
                ;;
            *)
                log_error "Unknown delete-user option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    # Check if reassign_to user exists
    if [[ -n "$reassign_to" ]] && ! user_exists "$reassign_to"; then
        log_error "Reassign target user '$reassign_to' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    # Confirm deletion unless --force is used
    if [[ "$FORCE" != "true" ]]; then
        echo -n "Are you sure you want to delete user '$target_user'? (y/N): " >&2
        read -r confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            log_info "User deletion cancelled"
            exit 0
        fi
    fi

    log_info "Deleting user: $target_user"

    # Terminate connections if requested
    if [[ "$terminate_connections" == "true" ]]; then
        log_info "Terminating active connections for user: $target_user"
        execute_sql "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE usename = '$target_user';" "Terminate user connections"
    fi

    # Handle owned objects
    if [[ -n "$reassign_to" ]]; then
        log_info "Reassigning owned objects to: $reassign_to"
        if execute_sql "REASSIGN OWNED BY \"$target_user\" TO \"$reassign_to\";" "Reassign owned objects"; then
            log_success "Objects reassigned successfully"
        fi
    fi

    if [[ "$drop_owned" == "true" ]]; then
        log_info "Dropping objects owned by user: $target_user"
        if execute_sql "DROP OWNED BY \"$target_user\";" "Drop owned objects"; then
            log_success "Owned objects dropped successfully"
        fi
    fi

    # Delete the user
    if execute_sql "DROP USER \"$target_user\";" "Delete user"; then
        log_success "User '$target_user' deleted successfully"
    else
        log_error "Failed to delete user '$target_user'"
        log_error "Note: User may still own objects. Use --reassign-to or --drop-owned options."
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_revoke_access() {
    local target_user=""
    local target_db=""
    local privileges="ALL"
    local schema=""
    local table_privileges=""
    local revoke_all_tables=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --table-privileges)
                table_privileges="$2"
                shift 2
                ;;
            --revoke-all-tables)
                revoke_all_tables=true
                shift
                ;;
            --help)
                show_revoke_access_help
                exit 0
                ;;
            *)
                log_error "Unknown revoke-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Revoking access for user: $target_user"

    # Revoke database privileges
    if [[ -n "$target_db" ]]; then
        if database_exists "$target_db"; then
            if execute_sql "REVOKE $privileges ON DATABASE \"$target_db\" FROM \"$target_user\";" "Revoke database privileges"; then
                log_success "Database privileges revoked from '$target_db'"
            fi
        else
            log_warning "Database '$target_db' does not exist"
        fi
    fi

    # Revoke table privileges
    if [[ -n "$table_privileges" && -n "$target_db" ]]; then
        local table_db_url=$(echo "$DATABASE_URL" | sed "s|/[^/]*$|/$target_db|")
        local target_schema="${schema:-public}"

        if [[ "$revoke_all_tables" == "true" ]]; then
            if PGPASSWORD="${PGPASSWORD:-}" psql "$table_db_url" -c "REVOKE $table_privileges ON ALL TABLES IN SCHEMA \"$target_schema\" FROM \"$target_user\";" &>/dev/null; then
                log_success "Table privileges revoked from all tables in schema '$target_schema'"
            fi
        fi
    fi

    log_success "Access revocation completed for user '$target_user'"
}

cmd_show_user_permissions() {
    local target_user=""
    local target_db=""
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                case "$output_format" in
                    table|json) ;;
                    *)
                        log_error "Invalid output format: $output_format"
                        log_error "Valid formats: table, json"
                        exit $EXIT_GENERAL_ERROR
                        ;;
                esac
                shift 2
                ;;
            --help)
                show_show_user_permissions_help
                exit 0
                ;;
            *)
                log_error "Unknown show-user-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Showing permissions for user: $target_user"
    echo ""

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would show permissions for user '$target_user'"
        return 0
    fi

    # Show user basic info
    if [[ "$output_format" == "json" ]]; then
        echo "{"
        echo "  \"user\": \"$target_user\","
        echo "  \"basic_permissions\": {"
    else
        echo "=== User Information ==="
    fi

    # Get basic user permissions
    local user_info=$(psql "$DATABASE_URL" -t -c "
        SELECT
            rolsuper, rolcreatedb, rolcreaterole, rolcanlogin, rolconnlimit
        FROM pg_roles
        WHERE rolname = '$target_user';
    ")

    if [[ "$output_format" == "json" ]]; then
        IFS='|' read -r superuser createdb createrole login connlimit <<< "$user_info"
        echo "    \"superuser\": $(echo "$superuser" | xargs | tr 'tf' 'TF' | sed 's/T/true/;s/F/false/'),"
        echo "    \"createdb\": $(echo "$createdb" | xargs | tr 'tf' 'TF' | sed 's/T/true/;s/F/false/'),"
        echo "    \"createrole\": $(echo "$createrole" | xargs | tr 'tf' 'TF' | sed 's/T/true/;s/F/false/'),"
        echo "    \"login\": $(echo "$login" | xargs | tr 'tf' 'TF' | sed 's/T/true/;s/F/false/'),"
        echo "    \"connection_limit\": $(echo "$connlimit" | xargs)"
        echo "  },"
        echo "  \"database_permissions\": ["
    else
        IFS='|' read -r superuser createdb createrole login connlimit <<< "$user_info"
        printf "%-15s: %s\n" "Superuser" "$(echo "$superuser" | xargs)"
        printf "%-15s: %s\n" "Create DB" "$(echo "$createdb" | xargs)"
        printf "%-15s: %s\n" "Create Role" "$(echo "$createrole" | xargs)"
        printf "%-15s: %s\n" "Can Login" "$(echo "$login" | xargs)"
        printf "%-15s: %s\n" "Conn Limit" "$(echo "$connlimit" | xargs)"
        echo ""
        echo "=== Database Permissions ==="
        printf "%-20s %-30s\n" "DATABASE" "PRIVILEGES"
        printf "%-20s %-30s\n" "$(printf '%*s' 20 | tr ' ' '-')" "$(printf '%*s' 30 | tr ' ' '-')"
    fi

    # Show database permissions
    local db_query="
        SELECT
            d.datname,
            array_to_string(array_agg(privilege_type), ', ') as privileges
        FROM pg_database d
        LEFT JOIN (
            SELECT
                (aclexplode(datacl)).grantee as grantee_oid,
                (aclexplode(datacl)).privilege_type,
                oid as db_oid
            FROM pg_database
            WHERE datacl IS NOT NULL
        ) perms ON d.oid = perms.db_oid
        LEFT JOIN pg_roles r ON perms.grantee_oid = r.oid
        WHERE r.rolname = '$target_user'
        GROUP BY d.datname
        ORDER BY d.datname;
    "

    if [[ -n "$target_db" ]]; then
        db_query="$db_query AND d.datname = '$target_db'"
    fi

    local first_db=true
    while IFS='|' read -r dbname privileges; do
        if [[ "$output_format" == "json" ]]; then
            [[ "$first_db" == "false" ]] && echo ","
            echo "    {"
            echo "      \"database\": \"$(echo "$dbname" | xargs)\","
            echo "      \"privileges\": \"$(echo "$privileges" | xargs)\""
            echo -n "    }"
            first_db=false
        else
            printf "%-20s %-30s\n" "$(echo "$dbname" | xargs)" "$(echo "$privileges" | xargs)"
        fi
    done < <(psql "$DATABASE_URL" -t -c "$db_query")

    if [[ "$output_format" == "json" ]]; then
        echo ""
        echo "  ]"
        echo "}"
    fi
}

cmd_lock_user() {
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                echo "Usage: $SCRIPT_NAME lock-user --target-user <username> [connection-options]"
                exit 0
                ;;
            *)
                log_error "Unknown lock-user option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Locking user (disabling login): $target_user"

    if execute_sql "ALTER USER \"$target_user\" NOLOGIN;" "Lock user"; then
        log_success "User '$target_user' locked successfully (login disabled)"
    else
        log_error "Failed to lock user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_unlock_user() {
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                echo "Usage: $SCRIPT_NAME unlock-user --target-user <username> [connection-options]"
                exit 0
                ;;
            *)
                log_error "Unknown unlock-user option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Unlocking user (enabling login): $target_user"

    if execute_sql "ALTER USER \"$target_user\" LOGIN;" "Unlock user"; then
        log_success "User '$target_user' unlocked successfully (login enabled)"
    else
        log_error "Failed to unlock user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_terminate_user_connections() {
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                echo "Usage: $SCRIPT_NAME terminate-user-connections --target-user <username> [connection-options]"
                exit 0
                ;;
            *)
                log_error "Unknown terminate-user-connections option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Terminating active connections for user: $target_user"

    # Get current connection count
    local connection_count=$(execute_sql_with_output "SELECT COUNT(*) FROM pg_stat_activity WHERE usename = '$target_user';" "Count user connections")

    if [[ "$connection_count" -eq 0 ]]; then
        log_info "No active connections found for user '$target_user'"
        return 0
    fi

    log_info "Found $connection_count active connection(s) for user '$target_user'"

    if execute_sql "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE usename = '$target_user';" "Terminate user connections"; then
        log_success "Terminated $connection_count connection(s) for user '$target_user'"
    else
        log_error "Failed to terminate connections for user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_grant_schema_access() {
    local target_user=""
    local target_schema=""
    local privileges="USAGE,CREATE"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-schema)
                target_schema=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-schema-access - Grant user access to specific schema

USAGE:
    $SCRIPT_NAME grant-schema-access --target-user <username> --target-schema <schema> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-schema <schema>    Schema name to grant access to

OPTIONAL OPTIONS:
    --privileges <privs>        Comma-separated privileges (default: USAGE,CREATE)
                               Available: USAGE, CREATE, ALL

EXAMPLES:
    # Grant usage and create on schema
    $SCRIPT_NAME grant-schema-access -U postgres --target-user myapp_user --target-schema myapp_schema

    # Grant all privileges on schema
    $SCRIPT_NAME grant-schema-access -U postgres --target-user myapp_user --target-schema myapp_schema --privileges ALL

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-schema-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_schema" ]]; then
        log_error "Target schema is required. Use --target-schema option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    # Check if schema exists
    local schema_exists=$(execute_sql_with_output "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name = '$target_schema';" "Check if schema exists")
    if [[ "$schema_exists" -eq 0 ]]; then
        log_error "Schema '$target_schema' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Granting schema access to user: $target_user on schema: $target_schema"

    if [[ "$privileges" == "ALL" ]]; then
        privileges="ALL PRIVILEGES"
    fi

    if execute_sql "GRANT $privileges ON SCHEMA \"$target_schema\" TO \"$target_user\";" "Grant schema privileges"; then
        log_success "Granted $privileges on schema '$target_schema' to user '$target_user'"
    else
        log_error "Failed to grant schema access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_create_db() {
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-create-db - Grant user permission to create databases

USAGE:
    $SCRIPT_NAME grant-create-db --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant CREATEDB privilege to

EXAMPLES:
    # Grant database creation privileges
    $SCRIPT_NAME grant-create-db -U postgres --target-user myapp_admin

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-create-db option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting CREATEDB privilege to user: $target_user"

    if execute_sql "ALTER USER \"$target_user\" CREATEDB;" "Grant CREATEDB privilege"; then
        log_success "Granted CREATEDB privilege to user '$target_user'"
    else
        log_error "Failed to grant CREATEDB privilege to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_sequence_access() {
    local target_user=""
    local target_sequence=""
    local privileges="USAGE,SELECT,UPDATE"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-sequence)
                target_sequence=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges=$(sanitize_string "$2")
                shift 2
                ;;
            --all-sequences)
                target_sequence="ALL SEQUENCES IN SCHEMA public"
                shift
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-sequence-access - Grant user access to sequences

USAGE:
    $SCRIPT_NAME grant-sequence-access --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to

SEQUENCE OPTIONS:
    --target-sequence <seq>     Specific sequence name
    --all-sequences            Grant access to all sequences in public schema

OPTIONAL OPTIONS:
    --privileges <privs>        Comma-separated privileges (default: USAGE,SELECT,UPDATE)
                               Available: USAGE, SELECT, UPDATE, ALL

EXAMPLES:
    # Grant access to specific sequence
    $SCRIPT_NAME grant-sequence-access -U postgres --target-user myapp_user --target-sequence user_id_seq

    # Grant access to all sequences in public schema
    $SCRIPT_NAME grant-sequence-access -U postgres --target-user myapp_user --all-sequences

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-sequence-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_sequence" ]]; then
        log_error "Target sequence is required. Use --target-sequence or --all-sequences option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting sequence access to user: $target_user on: $target_sequence"

    if [[ "$privileges" == "ALL" ]]; then
        privileges="ALL PRIVILEGES"
    fi

    if execute_sql "GRANT $privileges ON $target_sequence TO \"$target_user\";" "Grant sequence privileges"; then
        log_success "Granted $privileges on '$target_sequence' to user '$target_user'"
    else
        log_error "Failed to grant sequence access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_show_active_connections() {
    local target_user=""
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                case "$output_format" in
                    table|csv|json) ;;
                    *)
                        log_error "Invalid output format: $output_format"
                        log_error "Valid formats: table, csv, json"
                        exit $EXIT_GENERAL_ERROR
                        ;;
                esac
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME show-active-connections - Show active database connections

USAGE:
    $SCRIPT_NAME show-active-connections [options]

OPTIONAL OPTIONS:
    --target-user <username>    Show connections for specific user only
    --format <format>           Output format: table, csv, json (default: table)

EXAMPLES:
    # Show all active connections
    $SCRIPT_NAME show-active-connections -U postgres

    # Show connections for specific user
    $SCRIPT_NAME show-active-connections -U postgres --target-user myapp_user

    # Show connections in JSON format
    $SCRIPT_NAME show-active-connections -U postgres --format json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown show-active-connections option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Showing active database connections"

    local query="SELECT pid, usename, application_name, client_addr, state, query_start, query FROM pg_stat_activity WHERE state != 'idle'"

    if [[ -n "$target_user" ]]; then
        query="$query AND usename = '$target_user'"
    fi

    query="$query ORDER BY query_start DESC;"

    case "$output_format" in
        table)
            execute_sql_query "$query"
            ;;
        csv)
            execute_sql_with_output "COPY ($query) TO STDOUT WITH CSV HEADER;" "Export connections to CSV"
            ;;
        json)
            execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($query) t;" "Export connections to JSON"
            ;;
    esac
}

cmd_create_role() {
    local role_name=""
    local role_options=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --role-name)
                validate_username "$2"
                role_name="$2"
                shift 2
                ;;
            --login)
                role_options="${role_options} LOGIN"
                shift
                ;;
            --nologin)
                role_options="${role_options} NOLOGIN"
                shift
                ;;
            --createdb)
                role_options="${role_options} CREATEDB"
                shift
                ;;
            --createrole)
                role_options="${role_options} CREATEROLE"
                shift
                ;;
            --superuser)
                role_options="${role_options} SUPERUSER"
                shift
                ;;
            --inherit)
                role_options="${role_options} INHERIT"
                shift
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME create-role - Create a database role

USAGE:
    $SCRIPT_NAME create-role --role-name <rolename> [options]

REQUIRED OPTIONS:
    --role-name <rolename>      Name of the role to create

ROLE OPTIONS:
    --login                     Allow role to login (default for users)
    --nologin                   Disallow role login (default for roles)
    --createdb                  Allow role to create databases
    --createrole                Allow role to create other roles
    --superuser                 Grant superuser privileges (use with caution)
    --inherit                   Role inherits privileges of roles it's a member of

EXAMPLES:
    # Create a basic role
    $SCRIPT_NAME create-role -U postgres --role-name app_readers --nologin

    # Create a role that can create databases
    $SCRIPT_NAME create-role -U postgres --role-name db_creators --nologin --createdb

    # Create an admin role
    $SCRIPT_NAME create-role -U postgres --role-name app_admins --nologin --createrole

EOF
                exit 0
                ;;
            *)
                log_error "Unknown create-role option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$role_name" ]]; then
        log_error "Role name is required. Use --role-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    # Default to NOLOGIN for roles
    if [[ ! "$role_options" =~ LOGIN ]]; then
        role_options="NOLOGIN${role_options}"
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    # Check if role already exists
    if user_exists "$role_name"; then
        log_error "Role '$role_name' already exists"
        exit $EXIT_USER_EXISTS_ERROR
    fi

    log_info "Creating role: $role_name with options: $role_options"

    if execute_sql "CREATE ROLE \"$role_name\" $role_options;" "Create role"; then
        log_success "Role '$role_name' created successfully"
    else
        log_error "Failed to create role '$role_name'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_assign_role() {
    local target_user=""
    local role_name=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --role-name)
                validate_username "$2"
                role_name="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME assign-role - Assign role to user

USAGE:
    $SCRIPT_NAME assign-role --target-user <username> --role-name <rolename> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to assign role to
    --role-name <rolename>      Role name to assign

EXAMPLES:
    # Assign role to user
    $SCRIPT_NAME assign-role -U postgres --target-user myapp_user --role-name app_readers

    # Assign admin role to user
    $SCRIPT_NAME assign-role -U postgres --target-user admin_user --role-name app_admins

EOF
                exit 0
                ;;
            *)
                log_error "Unknown assign-role option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$role_name" ]]; then
        log_error "Role name is required. Use --role-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! user_exists "$role_name"; then
        log_error "Role '$role_name' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Assigning role '$role_name' to user '$target_user'"

    if execute_sql "GRANT \"$role_name\" TO \"$target_user\";" "Assign role to user"; then
        log_success "Role '$role_name' assigned to user '$target_user'"
    else
        log_error "Failed to assign role '$role_name' to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_list_roles() {
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --format)
                output_format="$2"
                case "$output_format" in
                    table|csv|json) ;;
                    *)
                        log_error "Invalid output format: $output_format"
                        log_error "Valid formats: table, csv, json"
                        exit $EXIT_GENERAL_ERROR
                        ;;
                esac
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME list-roles - List database roles

USAGE:
    $SCRIPT_NAME list-roles [options]

OPTIONAL OPTIONS:
    --format <format>           Output format: table, csv, json (default: table)

EXAMPLES:
    # List all roles
    $SCRIPT_NAME list-roles -U postgres

    # List roles in JSON format
    $SCRIPT_NAME list-roles -U postgres --format json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown list-roles option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Listing database roles"

    local query="SELECT rolname, rolcanlogin, rolcreatedb, rolcreaterole, rolsuper FROM pg_roles ORDER BY rolname;"

    case "$output_format" in
        table)
            execute_sql_query "$query"
            ;;
        csv)
            execute_sql_with_output "COPY ($query) TO STDOUT WITH CSV HEADER;" "Export roles to CSV"
            ;;
        json)
            execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($query) t;" "Export roles to JSON"
            ;;
    esac
}

cmd_copy_user_permissions() {
    local source_user=""
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --source-user)
                validate_username "$2"
                source_user="$2"
                shift 2
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME copy-user-permissions - Copy permissions from one user to another

USAGE:
    $SCRIPT_NAME copy-user-permissions --source-user <username> --target-user <username> [options]

REQUIRED OPTIONS:
    --source-user <username>    Username to copy permissions from
    --target-user <username>    Username to copy permissions to

EXAMPLES:
    # Copy permissions from one user to another
    $SCRIPT_NAME copy-user-permissions -U postgres --source-user template_user --target-user new_user

EOF
                exit 0
                ;;
            *)
                log_error "Unknown copy-user-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$source_user" ]]; then
        log_error "Source username is required. Use --source-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$source_user"; then
        log_error "Source user '$source_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! user_exists "$target_user"; then
        log_error "Target user '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Copying permissions from '$source_user' to '$target_user'"

    # Copy role memberships
    local roles_query="SELECT string_agg('GRANT \"' || r.rolname || '\" TO \"$target_user\";', E'\n') FROM pg_auth_members m JOIN pg_roles r ON m.roleid = r.oid JOIN pg_roles u ON m.member = u.oid WHERE u.rolname = '$source_user';"

    local grant_statements=$(execute_sql_with_output "$roles_query" "Get role grant statements")

    if [[ -n "$grant_statements" && "$grant_statements" != "" ]]; then
        log_verbose "Copying role memberships..."
        if execute_sql "$grant_statements" "Copy role memberships"; then
            log_success "Role memberships copied successfully"
        fi
    else
        log_info "No role memberships to copy"
    fi

    log_success "Permissions copied from '$source_user' to '$target_user'"
}

cmd_reset_user() {
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME reset-user - Reset user (revoke all permissions and role memberships)

USAGE:
    $SCRIPT_NAME reset-user --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to reset

EXAMPLES:
    # Reset user permissions
    $SCRIPT_NAME reset-user -U postgres --target-user old_user

EOF
                exit 0
                ;;
            *)
                log_error "Unknown reset-user option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Resetting user: $target_user"

    # Revoke all role memberships
    local revoke_roles_query="SELECT string_agg('REVOKE \"' || r.rolname || '\" FROM \"$target_user\";', E'\n') FROM pg_auth_members m JOIN pg_roles r ON m.roleid = r.oid JOIN pg_roles u ON m.member = u.oid WHERE u.rolname = '$target_user';"

    local revoke_statements=$(execute_sql_with_output "$revoke_roles_query" "Get role revoke statements")

    if [[ -n "$revoke_statements" && "$revoke_statements" != "" ]]; then
        log_verbose "Revoking role memberships..."
        if execute_sql "$revoke_statements" "Revoke role memberships"; then
            log_success "Role memberships revoked"
        fi
    fi

    # Reset user attributes
    if execute_sql "ALTER USER \"$target_user\" NOCREATEDB NOCREATEROLE NOSUPERUSER;" "Reset user attributes"; then
        log_success "User attributes reset"
    fi

    log_success "User '$target_user' has been reset"
}

cmd_set_connection_limit() {
    local target_user=""
    local connection_limit=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --limit)
                validate_numeric "$2" "connection-limit" -1 999999
                connection_limit="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME set-connection-limit - Set connection limit for user

USAGE:
    $SCRIPT_NAME set-connection-limit --target-user <username> --limit <number> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to set limit for
    --limit <number>           Connection limit (-1 for unlimited, 0+ for specific limit)

EXAMPLES:
    # Set connection limit to 5
    $SCRIPT_NAME set-connection-limit -U postgres --target-user myapp_user --limit 5

    # Remove connection limit (unlimited)
    $SCRIPT_NAME set-connection-limit -U postgres --target-user myapp_user --limit -1

EOF
                exit 0
                ;;
            *)
                log_error "Unknown set-connection-limit option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$connection_limit" ]]; then
        log_error "Connection limit is required. Use --limit option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Setting connection limit for user '$target_user' to $connection_limit"

    if execute_sql "ALTER USER \"$target_user\" CONNECTION LIMIT $connection_limit;" "Set connection limit"; then
        if [[ "$connection_limit" -eq -1 ]]; then
            log_success "Connection limit removed for user '$target_user'"
        else
            log_success "Connection limit set to $connection_limit for user '$target_user'"
        fi
    else
        log_error "Failed to set connection limit for user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_audit_permissions() {
    local output_format="table"
    local output_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --format)
                output_format="$2"
                case "$output_format" in
                    table|csv|json) ;;
                    *)
                        log_error "Invalid output format: $output_format"
                        log_error "Valid formats: table, csv, json"
                        exit $EXIT_GENERAL_ERROR
                        ;;
                esac
                shift 2
                ;;
            --output-file)
                output_file="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME audit-permissions - Generate comprehensive permissions report

USAGE:
    $SCRIPT_NAME audit-permissions [options]

OPTIONAL OPTIONS:
    --format <format>           Output format: table, csv, json (default: table)
    --output-file <path>        Save report to file

EXAMPLES:
    # Generate permissions audit
    $SCRIPT_NAME audit-permissions -U postgres

    # Generate CSV report
    $SCRIPT_NAME audit-permissions -U postgres --format csv --output-file permissions_audit.csv

    # Generate JSON report
    $SCRIPT_NAME audit-permissions -U postgres --format json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown audit-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Generating comprehensive permissions audit"

    local audit_query="
    WITH user_roles AS (
        SELECT
            r.rolname as username,
            array_agg(rr.rolname ORDER BY rr.rolname) as roles
        FROM pg_roles r
        LEFT JOIN pg_auth_members m ON r.oid = m.member
        LEFT JOIN pg_roles rr ON m.roleid = rr.oid
        WHERE r.rolcanlogin = true
        GROUP BY r.rolname
    ),
    user_attributes AS (
        SELECT
            rolname as username,
            rolcanlogin as can_login,
            rolcreatedb as can_create_db,
            rolcreaterole as can_create_role,
            rolsuper as is_superuser,
            rolconnlimit as connection_limit
        FROM pg_roles
        WHERE rolcanlogin = true
    )
    SELECT
        ua.username,
        ua.can_login,
        ua.can_create_db,
        ua.can_create_role,
        ua.is_superuser,
        ua.connection_limit,
        COALESCE(ur.roles::text, '{}') as assigned_roles
    FROM user_attributes ua
    LEFT JOIN user_roles ur ON ua.username = ur.username
    ORDER BY ua.username;
    "

    local output=""
    case "$output_format" in
        table)
            output=$(execute_sql_query "$audit_query")
            ;;
        csv)
            output=$(execute_sql_with_output "COPY ($audit_query) TO STDOUT WITH CSV HEADER;" "Generate CSV audit")
            ;;
        json)
            output=$(execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($audit_query) t;" "Generate JSON audit")
            ;;
    esac

    if [[ -n "$output_file" ]]; then
        echo "$output" > "$output_file"
        log_success "Permissions audit saved to: $output_file"
    else
        echo "$output"
    fi

    log_success "Permissions audit completed"
}

cmd_validate_permissions() {
    local target_user=""
    local required_permissions=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --required-permissions)
                required_permissions="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME validate-permissions - Validate user has minimum required permissions

USAGE:
    $SCRIPT_NAME validate-permissions --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>         Username to validate

OPTIONAL OPTIONS:
    --required-permissions <perms>   Comma-separated list of required permissions
                                    Available: LOGIN,CREATEDB,CREATEROLE,SUPERUSER

EXAMPLES:
    # Validate user can login
    $SCRIPT_NAME validate-permissions -U postgres --target-user myapp_user --required-permissions LOGIN

    # Validate user has admin permissions
    $SCRIPT_NAME validate-permissions -U postgres --target-user admin_user --required-permissions LOGIN,CREATEDB,CREATEROLE

EOF
                exit 0
                ;;
            *)
                log_error "Unknown validate-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Validating permissions for user: $target_user"

    # Get user attributes
    local user_query="SELECT rolcanlogin, rolcreatedb, rolcreaterole, rolsuper FROM pg_roles WHERE rolname = '$target_user';"
    local user_attrs=$(execute_sql_with_output "$user_query" "Get user attributes")

    IFS='|' read -r can_login can_create_db can_create_role is_superuser <<< "$user_attrs"

    local validation_failed=false
    local missing_permissions=()

    if [[ -n "$required_permissions" ]]; then
        IFS=',' read -ra PERMS <<< "$required_permissions"
        for perm in "${PERMS[@]}"; do
            case "$perm" in
                LOGIN)
                    if [[ "$can_login" != "t" ]]; then
                        missing_permissions+=("LOGIN")
                        validation_failed=true
                    fi
                    ;;
                CREATEDB)
                    if [[ "$can_create_db" != "t" ]]; then
                        missing_permissions+=("CREATEDB")
                        validation_failed=true
                    fi
                    ;;
                CREATEROLE)
                    if [[ "$can_create_role" != "t" ]]; then
                        missing_permissions+=("CREATEROLE")
                        validation_failed=true
                    fi
                    ;;
                SUPERUSER)
                    if [[ "$is_superuser" != "t" ]]; then
                        missing_permissions+=("SUPERUSER")
                        validation_failed=true
                    fi
                    ;;
            esac
        done
    fi

    if [[ "$validation_failed" == "true" ]]; then
        log_error "Validation failed. User '$target_user' is missing permissions: ${missing_permissions[*]}"
        exit $EXIT_PERMISSION_ERROR
    else
        log_success "Validation passed. User '$target_user' has all required permissions."
    fi
}

cmd_backup_permissions() {
    local output_file=""
    local target_user=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --output-file)
                output_file="$2"
                shift 2
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME backup-permissions - Export user permissions to file

USAGE:
    $SCRIPT_NAME backup-permissions --output-file <file> [options]

REQUIRED OPTIONS:
    --output-file <file>        File to save permissions backup to

OPTIONAL OPTIONS:
    --target-user <username>    Backup permissions for specific user only

EXAMPLES:
    # Backup all user permissions
    $SCRIPT_NAME backup-permissions -U postgres --output-file permissions_backup.sql

    # Backup specific user permissions
    $SCRIPT_NAME backup-permissions -U postgres --target-user myapp_user --output-file myapp_user_backup.sql

EOF
                exit 0
                ;;
            *)
                log_error "Unknown backup-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$output_file" ]]; then
        log_error "Output file is required. Use --output-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Backing up permissions to: $output_file"

    {
        echo "-- PostgreSQL User Permissions Backup"
        echo "-- Generated on: $(date)"
        echo "-- Database: $(parse_database_url "$DATABASE_URL")"
        echo ""

        local user_filter=""
        if [[ -n "$target_user" ]]; then
            user_filter="WHERE rolname = '$target_user'"
            if ! user_exists "$target_user"; then
                log_error "User '$target_user' does not exist"
                exit $EXIT_USER_NOT_EXISTS_ERROR
            fi
        else
            user_filter="WHERE rolcanlogin = true"
        fi

        # Generate CREATE USER statements
        echo "-- User Creation Statements"
        local user_create_query="
        SELECT 'CREATE USER \"' || rolname || '\"' ||
               CASE WHEN rolcanlogin THEN ' LOGIN' ELSE ' NOLOGIN' END ||
               CASE WHEN rolcreatedb THEN ' CREATEDB' ELSE ' NOCREATEDB' END ||
               CASE WHEN rolcreaterole THEN ' CREATEROLE' ELSE ' NOCREATEROLE' END ||
               CASE WHEN rolsuper THEN ' SUPERUSER' ELSE ' NOSUPERUSER' END ||
               CASE WHEN rolconnlimit != -1 THEN ' CONNECTION LIMIT ' || rolconnlimit ELSE '' END ||
               ';' as create_statement
        FROM pg_roles
        $user_filter
        ORDER BY rolname;
        "

        execute_sql_with_output "$user_create_query" "Generate user creation statements"

        echo ""
        echo "-- Role Membership Statements"

        # Generate GRANT role statements
        local role_grant_query="
        SELECT 'GRANT \"' || r.rolname || '\" TO \"' || u.rolname || '\";' as grant_statement
        FROM pg_auth_members m
        JOIN pg_roles r ON m.roleid = r.oid
        JOIN pg_roles u ON m.member = u.oid
        WHERE u.rolcanlogin = true"

        if [[ -n "$target_user" ]]; then
            role_grant_query="$role_grant_query AND u.rolname = '$target_user'"
        fi

        role_grant_query="$role_grant_query ORDER BY u.rolname, r.rolname;"

        execute_sql_with_output "$role_grant_query" "Generate role grant statements"

        echo ""
        echo "-- End of permissions backup"

    } > "$output_file"

    log_success "Permissions backup saved to: $output_file"
}

cmd_restore_permissions() {
    local input_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --input-file)
                input_file="$2"
                if [[ ! -f "$input_file" ]]; then
                    log_error "Input file not found: $input_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME restore-permissions - Import user permissions from file

USAGE:
    $SCRIPT_NAME restore-permissions --input-file <file> [options]

REQUIRED OPTIONS:
    --input-file <file>         File to restore permissions from

EXAMPLES:
    # Restore permissions from backup
    $SCRIPT_NAME restore-permissions -U postgres --input-file permissions_backup.sql

EOF
                exit 0
                ;;
            *)
                log_error "Unknown restore-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$input_file" ]]; then
        log_error "Input file is required. Use --input-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Restoring permissions from: $input_file"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would execute SQL statements from $input_file"
        grep -E "^(CREATE USER|GRANT)" "$input_file" || true
    else
        if execute_sql_file "$input_file"; then
            log_success "Permissions restored successfully from: $input_file"
        else
            log_error "Failed to restore permissions from: $input_file"
            exit $EXIT_GENERAL_ERROR
        fi
    fi
}

cmd_revoke_role() {
    local target_user=""
    local role_name=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --role-name)
                validate_username "$2"
                role_name="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME revoke-role - Revoke role from user

USAGE:
    $SCRIPT_NAME revoke-role --target-user <username> --role-name <rolename> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to revoke role from
    --role-name <rolename>      Role name to revoke

EXAMPLES:
    # Revoke role from user
    $SCRIPT_NAME revoke-role -U postgres --target-user myapp_user --role-name app_readers

EOF
                exit 0
                ;;
            *)
                log_error "Unknown revoke-role option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$role_name" ]]; then
        log_error "Role name is required. Use --role-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! user_exists "$role_name"; then
        log_error "Role '$role_name' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Revoking role '$role_name' from user '$target_user'"

    if execute_sql "REVOKE \"$role_name\" FROM \"$target_user\";" "Revoke role from user"; then
        log_success "Role '$role_name' revoked from user '$target_user'"
    else
        log_error "Failed to revoke role '$role_name' from user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_list_user_roles() {
    local target_user=""
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME list-user-roles - List roles for specific user

USAGE:
    $SCRIPT_NAME list-user-roles --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to list roles for

OPTIONAL OPTIONS:
    --format <format>           Output format: table, json (default: table)

EXAMPLES:
    # List roles for user
    $SCRIPT_NAME list-user-roles -U postgres --target-user myapp_user

EOF
                exit 0
                ;;
            *)
                log_error "Unknown list-user-roles option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Listing roles for user: $target_user"

    local query="SELECT r.rolname as role_name FROM pg_auth_members m JOIN pg_roles r ON m.roleid = r.oid JOIN pg_roles u ON m.member = u.oid WHERE u.rolname = '$target_user' ORDER BY r.rolname;"

    if [[ "$output_format" == "json" ]]; then
        execute_sql_with_output "SELECT json_agg(role_name) FROM ($query) t;" "Get user roles as JSON"
    else
        execute_sql_query "$query"
    fi
}

cmd_list_role_members() {
    local role_name=""
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --role-name)
                validate_username "$2"
                role_name="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME list-role-members - List users who have specific role

USAGE:
    $SCRIPT_NAME list-role-members --role-name <rolename> [options]

REQUIRED OPTIONS:
    --role-name <rolename>      Role name to list members for

OPTIONAL OPTIONS:
    --format <format>           Output format: table, json (default: table)

EXAMPLES:
    # List members of role
    $SCRIPT_NAME list-role-members -U postgres --role-name app_readers

EOF
                exit 0
                ;;
            *)
                log_error "Unknown list-role-members option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$role_name" ]]; then
        log_error "Role name is required. Use --role-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$role_name"; then
        log_error "Role '$role_name' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Listing members of role: $role_name"

    local query="SELECT u.rolname as username FROM pg_auth_members m JOIN pg_roles r ON m.roleid = r.oid JOIN pg_roles u ON m.member = u.oid WHERE r.rolname = '$role_name' ORDER BY u.rolname;"

    if [[ "$output_format" == "json" ]]; then
        execute_sql_with_output "SELECT json_agg(username) FROM ($query) t;" "Get role members as JSON"
    else
        execute_sql_query "$query"
    fi
}

cmd_grant_table_access() {
    local target_user=""
    local target_table=""
    local privileges="SELECT"
    local schema="public"
    local with_grant_option=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --with-grant-option)
                with_grant_option=true
                shift
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-table-access - Grant user access to specific tables

USAGE:
    $SCRIPT_NAME grant-table-access --target-user <username> --target-table <table> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-table <table>      Table name to grant access to

OPTIONAL OPTIONS:
    --privileges <privs>        Comma-separated privileges (default: SELECT)
                               Available: SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,ALL
    --schema <name>            Schema name (default: public)
    --with-grant-option        Allow user to grant these privileges to others

EXAMPLES:
    # Grant SELECT access to table
    $SCRIPT_NAME grant-table-access -U postgres --target-user myapp_user --target-table users

    # Grant full access with grant option
    $SCRIPT_NAME grant-table-access -U postgres --target-user admin_user --target-table users --privileges ALL --with-grant-option

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-table-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting table access to user: $target_user on table: $schema.$target_table"

    local grant_sql="GRANT $privileges ON TABLE \"$schema\".\"$target_table\" TO \"$target_user\""

    if [[ "$with_grant_option" == "true" ]]; then
        grant_sql="$grant_sql WITH GRANT OPTION"
    fi

    grant_sql="$grant_sql;"

    if execute_sql "$grant_sql" "Grant table privileges"; then
        log_success "Granted $privileges on table '$schema.$target_table' to user '$target_user'"
    else
        log_error "Failed to grant table access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_revoke_table_access() {
    local target_user=""
    local target_table=""
    local privileges="ALL"
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME revoke-table-access - Revoke user table permissions

USAGE:
    $SCRIPT_NAME revoke-table-access --target-user <username> --target-table <table> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to revoke access from
    --target-table <table>      Table name to revoke access from

OPTIONAL OPTIONS:
    --privileges <privs>        Privileges to revoke (default: ALL)
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Revoke all access from table
    $SCRIPT_NAME revoke-table-access -U postgres --target-user myapp_user --target-table users

EOF
                exit 0
                ;;
            *)
                log_error "Unknown revoke-table-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Revoking table access from user: $target_user on table: $schema.$target_table"

    if execute_sql "REVOKE $privileges ON TABLE \"$schema\".\"$target_table\" FROM \"$target_user\";" "Revoke table privileges"; then
        log_success "Revoked $privileges on table '$schema.$target_table' from user '$target_user'"
    else
        log_error "Failed to revoke table access from user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_function_access() {
    local target_user=""
    local target_function=""
    local privileges="EXECUTE"
    local schema="public"
    local with_grant_option=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-function)
                target_function=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --with-grant-option)
                with_grant_option=true
                shift
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-function-access - Grant user access to functions/procedures

USAGE:
    $SCRIPT_NAME grant-function-access --target-user <username> --target-function <function> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-function <func>    Function name to grant access to

OPTIONAL OPTIONS:
    --privileges <privs>        Privileges (default: EXECUTE)
    --schema <name>            Schema name (default: public)
    --with-grant-option        Allow user to grant these privileges to others

EXAMPLES:
    # Grant EXECUTE access to function
    $SCRIPT_NAME grant-function-access -U postgres --target-user myapp_user --target-function my_function

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-function-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_function" ]]; then
        log_error "Target function is required. Use --target-function option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting function access to user: $target_user on function: $schema.$target_function"

    local grant_sql="GRANT $privileges ON FUNCTION \"$schema\".\"$target_function\" TO \"$target_user\""

    if [[ "$with_grant_option" == "true" ]]; then
        grant_sql="$grant_sql WITH GRANT OPTION"
    fi

    grant_sql="$grant_sql;"

    if execute_sql "$grant_sql" "Grant function privileges"; then
        log_success "Granted $privileges on function '$schema.$target_function' to user '$target_user'"
    else
        log_error "Failed to grant function access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_view_access() {
    local target_user=""
    local target_view=""
    local privileges="SELECT"
    local schema="public"
    local with_grant_option=false

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-view)
                target_view=$(sanitize_string "$2")
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --with-grant-option)
                with_grant_option=true
                shift
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-view-access - Grant user access to views

USAGE:
    $SCRIPT_NAME grant-view-access --target-user <username> --target-view <view> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-view <view>        View name to grant access to

OPTIONAL OPTIONS:
    --privileges <privs>        Privileges (default: SELECT)
    --schema <name>            Schema name (default: public)
    --with-grant-option        Allow user to grant these privileges to others

EXAMPLES:
    # Grant SELECT access to view
    $SCRIPT_NAME grant-view-access -U postgres --target-user myapp_user --target-view user_summary

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-view-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_view" ]]; then
        log_error "Target view is required. Use --target-view option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting view access to user: $target_user on view: $schema.$target_view"

    local grant_sql="GRANT $privileges ON \"$schema\".\"$target_view\" TO \"$target_user\""

    if [[ "$with_grant_option" == "true" ]]; then
        grant_sql="$grant_sql WITH GRANT OPTION"
    fi

    grant_sql="$grant_sql;"

    if execute_sql "$grant_sql" "Grant view privileges"; then
        log_success "Granted $privileges on view '$schema.$target_view' to user '$target_user'"
    else
        log_error "Failed to grant view access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_column_access() {
    local target_user=""
    local target_table=""
    local target_columns=""
    local privileges="SELECT"
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --target-columns)
                target_columns="$2"
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-column-access - Grant user access to specific columns

USAGE:
    $SCRIPT_NAME grant-column-access --target-user <username> --target-table <table> --target-columns <cols> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-table <table>      Table name
    --target-columns <cols>     Comma-separated column names

OPTIONAL OPTIONS:
    --privileges <privs>        Privileges (default: SELECT)
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Grant SELECT access to specific columns
    $SCRIPT_NAME grant-column-access -U postgres --target-user myapp_user --target-table users --target-columns id,name,email

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-column-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_columns" ]]; then
        log_error "Target columns are required. Use --target-columns option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting column access to user: $target_user on table: $schema.$target_table"

    # Format columns for SQL
    local formatted_columns=$(echo "$target_columns" | sed 's/,/", "/g' | sed 's/^/"/' | sed 's/$/"/')

    if execute_sql "GRANT $privileges ($formatted_columns) ON \"$schema\".\"$target_table\" TO \"$target_user\";" "Grant column privileges"; then
        log_success "Granted $privileges on columns ($target_columns) of table '$schema.$target_table' to user '$target_user'"
    else
        log_error "Failed to grant column access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_grant_tablespace_access() {
    local target_user=""
    local target_tablespace=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --target-tablespace)
                target_tablespace=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME grant-tablespace-access - Grant user access to tablespaces

USAGE:
    $SCRIPT_NAME grant-tablespace-access --target-user <username> --target-tablespace <tablespace> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to grant access to
    --target-tablespace <name>  Tablespace name

EXAMPLES:
    # Grant CREATE access to tablespace
    $SCRIPT_NAME grant-tablespace-access -U postgres --target-user myapp_user --target-tablespace fast_storage

EOF
                exit 0
                ;;
            *)
                log_error "Unknown grant-tablespace-access option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_tablespace" ]]; then
        log_error "Target tablespace is required. Use --target-tablespace option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Granting tablespace access to user: $target_user on tablespace: $target_tablespace"

    if execute_sql "GRANT CREATE ON TABLESPACE \"$target_tablespace\" TO \"$target_user\";" "Grant tablespace privileges"; then
        log_success "Granted CREATE on tablespace '$target_tablespace' to user '$target_user'"
    else
        log_error "Failed to grant tablespace access to user '$target_user'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_rotate_password() {
    local target_user=""
    local auto_generate=false
    local new_password=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --auto-generate)
                auto_generate=true
                shift
                ;;
            --new-password)
                new_password="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME rotate-password - Rotate user password with auto-generation

USAGE:
    $SCRIPT_NAME rotate-password --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to rotate password for

OPTIONAL OPTIONS:
    --auto-generate            Auto-generate secure password
    --new-password <pass>      Specify new password (prompted if not provided)

EXAMPLES:
    # Auto-generate password
    $SCRIPT_NAME rotate-password -U postgres --target-user myapp_user --auto-generate

EOF
                exit 0
                ;;
            *)
                log_error "Unknown rotate-password option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    # Generate password if auto-generate is enabled
    if [[ "$auto_generate" == "true" ]]; then
        new_password=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-20)
        log_info "Auto-generated password for user '$target_user': $new_password"
    elif [[ -z "$new_password" ]]; then
        echo -n "Enter new password for user '$target_user': " >&2
        read -s new_password
        echo >&2
    fi

    if [[ -z "$new_password" ]]; then
        log_error "Password cannot be empty"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Rotating password for user: $target_user"

    if execute_sql "ALTER USER \"$target_user\" WITH PASSWORD '$new_password';" "Rotate user password"; then
        log_success "Password rotated successfully for user '$target_user'"
        if [[ "$auto_generate" == "true" ]]; then
            log_info "New password: $new_password"
        fi
    else
        log_error "Failed to rotate password for user '$target_user'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_show_user_activity() {
    local target_user=""
    local last_days="7"
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --last-days)
                validate_numeric "$2" "last-days" 1 365
                last_days="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME show-user-activity - Show recent user activity

USAGE:
    $SCRIPT_NAME show-user-activity --target-user <username> [options]

REQUIRED OPTIONS:
    --target-user <username>    Username to show activity for

OPTIONAL OPTIONS:
    --last-days <days>         Number of days to look back (default: 7)
    --format <format>          Output format: table, json (default: table)

EXAMPLES:
    # Show activity for last 7 days
    $SCRIPT_NAME show-user-activity -U postgres --target-user myapp_user

    # Show activity for last 30 days in JSON
    $SCRIPT_NAME show-user-activity -U postgres --target-user myapp_user --last-days 30 --format json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown show-user-activity option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$target_user"; then
        log_error "User '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Showing recent activity for user: $target_user (last $last_days days)"

    # Current active connections
    local active_query="SELECT datname, client_addr, application_name, state, query_start FROM pg_stat_activity WHERE usename = '$target_user' AND state != 'idle' ORDER BY query_start DESC;"

    if [[ "$output_format" == "json" ]]; then
        execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($active_query) t;" "Get user activity as JSON"
    else
        execute_sql_query "$active_query"
    fi
}

cmd_security_scan() {
    local check_type="all"
    local output_format="table"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --check-type)
                check_type="$2"
                shift 2
                ;;
            --format)
                output_format="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME security-scan - Scan for security issues

USAGE:
    $SCRIPT_NAME security-scan [options]

OPTIONAL OPTIONS:
    --check-type <type>        Type of check: all, unused-permissions, superusers, weak-passwords (default: all)
    --format <format>          Output format: table, json (default: table)

EXAMPLES:
    # Full security scan
    $SCRIPT_NAME security-scan -U postgres

    # Check for superusers only
    $SCRIPT_NAME security-scan -U postgres --check-type superusers

EOF
                exit 0
                ;;
            *)
                log_error "Unknown security-scan option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Running security scan..."

    if [[ "$check_type" == "all" || "$check_type" == "superusers" ]]; then
        log_info "Checking for superuser accounts..."
        local superuser_query="SELECT rolname as username, 'Has superuser privileges' as issue FROM pg_roles WHERE rolsuper = true AND rolname NOT LIKE 'pg_%';"

        if [[ "$output_format" == "json" ]]; then
            execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($superuser_query) t;" "Get superusers as JSON"
        else
            execute_sql_query "$superuser_query"
        fi
    fi

    if [[ "$check_type" == "all" || "$check_type" == "unused-permissions" ]]; then
        log_info "Checking for users with CREATE privileges..."
        local create_db_query="SELECT rolname as username, 'Has CREATEDB privilege' as issue FROM pg_roles WHERE rolcreatedb = true AND rolname NOT LIKE 'pg_%';"

        if [[ "$output_format" == "json" ]]; then
            execute_sql_with_output "SELECT json_agg(row_to_json(t)) FROM ($create_db_query) t;" "Get users with CREATEDB as JSON"
        else
            execute_sql_query "$create_db_query"
        fi
    fi

    log_success "Security scan completed"
}

cmd_create_users_batch() {
    local users_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --users-file)
                users_file="$2"
                if [[ ! -f "$users_file" ]]; then
                    log_error "Users file not found: $users_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME create-users-batch - Create multiple users from file

USAGE:
    $SCRIPT_NAME create-users-batch --users-file <file> [options]

REQUIRED OPTIONS:
    --users-file <file>         JSON file with user definitions

FILE FORMAT:
    [
      {
        "username": "user1",
        "password": "password1",
        "superuser": false,
        "createdb": true,
        "createrole": false,
        "login": true
      },
      ...
    ]

EXAMPLES:
    # Create users from JSON file
    $SCRIPT_NAME create-users-batch -U postgres --users-file users.json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown create-users-batch option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$users_file" ]]; then
        log_error "Users file is required. Use --users-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Creating users from file: $users_file"

    # Simple JSON parsing for user creation
    local user_count=0
    while IFS= read -r line; do
        if [[ "$line" =~ \"username\":[[:space:]]*\"([^\"]+)\" ]]; then
            local username="${BASH_REMATCH[1]}"
            user_count=$((user_count + 1))

            # Extract password (simplified parsing)
            local password=""
            if [[ "$line" =~ \"password\":[[:space:]]*\"([^\"]+)\" ]]; then
                password="${BASH_REMATCH[1]}"
            fi

            # Check for flags
            local superuser_flag=""
            local createdb_flag=""
            local login_flag="LOGIN"

            if [[ "$line" =~ \"superuser\":[[:space:]]*true ]]; then
                superuser_flag="SUPERUSER"
            else
                superuser_flag="NOSUPERUSER"
            fi

            if [[ "$line" =~ \"createdb\":[[:space:]]*true ]]; then
                createdb_flag="CREATEDB"
            else
                createdb_flag="NOCREATEDB"
            fi

            if [[ "$line" =~ \"login\":[[:space:]]*false ]]; then
                login_flag="NOLOGIN"
            fi

            log_info "Creating user: $username"

            if user_exists "$username"; then
                log_warning "User '$username' already exists, skipping"
                continue
            fi

            local create_sql="CREATE USER \"$username\""
            if [[ -n "$password" ]]; then
                create_sql="$create_sql WITH PASSWORD '$password'"
            fi
            create_sql="$create_sql $superuser_flag $createdb_flag $login_flag;"

            if execute_sql "$create_sql" "Create user $username"; then
                log_success "User '$username' created successfully"
            else
                log_error "Failed to create user '$username'"
            fi
        fi
    done < "$users_file"

    log_success "Batch user creation completed. Processed $user_count user(s)"
}

cmd_bulk_grant() {
    local users_file=""
    local target_db=""
    local privileges=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --users-file)
                users_file="$2"
                if [[ ! -f "$users_file" ]]; then
                    log_error "Users file not found: $users_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME bulk-grant - Grant permissions to multiple users

USAGE:
    $SCRIPT_NAME bulk-grant --users-file <file> --target-db <database> --privileges <privs> [options]

REQUIRED OPTIONS:
    --users-file <file>         File with usernames (one per line)
    --target-db <database>      Database to grant access to
    --privileges <privs>        Privileges to grant

EXAMPLES:
    # Grant database access to multiple users
    $SCRIPT_NAME bulk-grant -U postgres --users-file users.txt --target-db myapp --privileges CONNECT,CREATE

EOF
                exit 0
                ;;
            *)
                log_error "Unknown bulk-grant option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$users_file" ]]; then
        log_error "Users file is required. Use --users-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_db" ]]; then
        log_error "Target database is required. Use --target-db option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$privileges" ]]; then
        log_error "Privileges are required. Use --privileges option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! database_exists "$target_db"; then
        log_error "Database '$target_db' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Granting permissions to multiple users from file: $users_file"

    local granted_count=0
    while IFS= read -r username; do
        # Skip empty lines and comments
        [[ -z "$username" || "$username" =~ ^[[:space:]]*# ]] && continue

        username=$(echo "$username" | xargs)  # Trim whitespace

        if ! user_exists "$username"; then
            log_warning "User '$username' does not exist, skipping"
            continue
        fi

        log_info "Granting $privileges on database '$target_db' to user '$username'"

        if execute_sql "GRANT $privileges ON DATABASE \"$target_db\" TO \"$username\";" "Grant privileges to $username"; then
            log_success "Granted privileges to user '$username'"
            granted_count=$((granted_count + 1))
        else
            log_error "Failed to grant privileges to user '$username'"
        fi
    done < "$users_file"

    log_success "Bulk grant completed. Granted privileges to $granted_count user(s)"
}

cmd_enable_rls() {
    local target_table=""
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME enable-rls - Enable row-level security on table

USAGE:
    $SCRIPT_NAME enable-rls --target-table <table> [options]

REQUIRED OPTIONS:
    --target-table <table>      Table name to enable RLS on

OPTIONAL OPTIONS:
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Enable RLS on table
    $SCRIPT_NAME enable-rls -U postgres --target-table users

EOF
                exit 0
                ;;
            *)
                log_error "Unknown enable-rls option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Enabling row-level security on table: $schema.$target_table"

    if execute_sql "ALTER TABLE \"$schema\".\"$target_table\" ENABLE ROW LEVEL SECURITY;" "Enable RLS"; then
        log_success "Row-level security enabled on table '$schema.$target_table'"
    else
        log_error "Failed to enable row-level security on table '$schema.$target_table'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_disable_rls() {
    local target_table=""
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME disable-rls - Disable row-level security on table

USAGE:
    $SCRIPT_NAME disable-rls --target-table <table> [options]

REQUIRED OPTIONS:
    --target-table <table>      Table name to disable RLS on

OPTIONAL OPTIONS:
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Disable RLS on table
    $SCRIPT_NAME disable-rls -U postgres --target-table users

EOF
                exit 0
                ;;
            *)
                log_error "Unknown disable-rls option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Disabling row-level security on table: $schema.$target_table"

    if execute_sql "ALTER TABLE \"$schema\".\"$target_table\" DISABLE ROW LEVEL SECURITY;" "Disable RLS"; then
        log_success "Row-level security disabled on table '$schema.$target_table'"
    else
        log_error "Failed to disable row-level security on table '$schema.$target_table'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_create_policy() {
    local policy_name=""
    local target_table=""
    local policy_command="ALL"
    local policy_using=""
    local policy_check=""
    local target_roles=""
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --policy-name)
                policy_name=$(sanitize_string "$2")
                shift 2
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --command)
                policy_command="$2"
                shift 2
                ;;
            --using)
                policy_using="$2"
                shift 2
                ;;
            --check)
                policy_check="$2"
                shift 2
                ;;
            --roles)
                target_roles="$2"
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME create-policy - Create row-level security policy

USAGE:
    $SCRIPT_NAME create-policy --policy-name <name> --target-table <table> [options]

REQUIRED OPTIONS:
    --policy-name <name>        Policy name
    --target-table <table>      Table name

OPTIONAL OPTIONS:
    --command <cmd>            Command type: ALL, SELECT, INSERT, UPDATE, DELETE (default: ALL)
    --using <expr>             USING expression for SELECT/UPDATE/DELETE
    --check <expr>             CHECK expression for INSERT/UPDATE
    --roles <roles>            Comma-separated role names (default: PUBLIC)
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Create policy for user to see only their own rows
    $SCRIPT_NAME create-policy -U postgres --policy-name user_policy --target-table users --using "user_id = current_user_id()"

EOF
                exit 0
                ;;
            *)
                log_error "Unknown create-policy option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$policy_name" ]]; then
        log_error "Policy name is required. Use --policy-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Creating policy '$policy_name' on table: $schema.$target_table"

    local create_policy_sql="CREATE POLICY \"$policy_name\" ON \"$schema\".\"$target_table\""

    if [[ -n "$target_roles" ]]; then
        create_policy_sql="$create_policy_sql FOR $policy_command TO $target_roles"
    else
        create_policy_sql="$create_policy_sql FOR $policy_command"
    fi

    if [[ -n "$policy_using" ]]; then
        create_policy_sql="$create_policy_sql USING ($policy_using)"
    fi

    if [[ -n "$policy_check" ]]; then
        create_policy_sql="$create_policy_sql WITH CHECK ($policy_check)"
    fi

    create_policy_sql="$create_policy_sql;"

    if execute_sql "$create_policy_sql" "Create RLS policy"; then
        log_success "Policy '$policy_name' created successfully on table '$schema.$target_table'"
    else
        log_error "Failed to create policy '$policy_name'"
        exit $EXIT_GENERAL_ERROR
    fi
}

cmd_clone_user_permissions() {
    local source_user=""
    local target_user=""
    local source_db=""
    local target_db=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --source-user)
                validate_username "$2"
                source_user="$2"
                shift 2
                ;;
            --target-user)
                validate_username "$2"
                target_user="$2"
                shift 2
                ;;
            --source-db)
                validate_db_name "$2"
                source_db="$2"
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME clone-user-permissions - Clone user permissions between databases

USAGE:
    $SCRIPT_NAME clone-user-permissions --source-user <user> --target-user <user> --source-db <db> --target-db <db> [options]

REQUIRED OPTIONS:
    --source-user <username>    Source username to copy permissions from
    --target-user <username>    Target username to copy permissions to
    --source-db <database>      Source database
    --target-db <database>      Target database

EXAMPLES:
    # Clone permissions between databases
    $SCRIPT_NAME clone-user-permissions -U postgres --source-user myapp_user --target-user myapp_user --source-db myapp_dev --target-db myapp_prod

EOF
                exit 0
                ;;
            *)
                log_error "Unknown clone-user-permissions option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$source_user" ]]; then
        log_error "Source username is required. Use --source-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_user" ]]; then
        log_error "Target username is required. Use --target-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$source_db" ]]; then
        log_error "Source database is required. Use --source-db option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_db" ]]; then
        log_error "Target database is required. Use --target-db option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$source_user"; then
        log_error "Source user '$source_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! user_exists "$target_user"; then
        log_error "Target user '$target_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    if ! database_exists "$source_db"; then
        log_error "Source database '$source_db' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    if ! database_exists "$target_db"; then
        log_error "Target database '$target_db' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Cloning permissions from '$source_user' in '$source_db' to '$target_user' in '$target_db'"

    # This is a simplified implementation - in practice you'd need to query and replicate specific permissions
    if execute_sql "GRANT CONNECT ON DATABASE \"$target_db\" TO \"$target_user\";" "Grant basic database access"; then
        log_success "Basic permissions cloned successfully"
    else
        log_error "Failed to clone permissions"
        exit $EXIT_PERMISSION_ERROR
    fi

    log_success "Permission cloning completed"
}

cmd_enable_rls() {
    local target_table=""
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME enable-rls - Enable row-level security on table

USAGE:
    $SCRIPT_NAME enable-rls --target-table <table> [options]

REQUIRED OPTIONS:
    --target-table <table>      Table name to enable RLS on

OPTIONAL OPTIONS:
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Enable RLS on table
    $SCRIPT_NAME enable-rls -U postgres --target-table users

EOF
                exit 0
                ;;
            *)
                log_error "Unknown enable-rls option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Enabling row-level security on table: $schema.$target_table"

    if execute_sql "ALTER TABLE \"$schema\".\"$target_table\" ENABLE ROW LEVEL SECURITY;" "Enable RLS"; then
        log_success "Row-level security enabled on table '$schema.$target_table'"
    else
        log_error "Failed to enable RLS on table '$schema.$target_table'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_disable_rls() {
    local target_table=""
    local schema="public"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME disable-rls - Disable row-level security on table

USAGE:
    $SCRIPT_NAME disable-rls --target-table <table> [options]

REQUIRED OPTIONS:
    --target-table <table>      Table name to disable RLS on

OPTIONAL OPTIONS:
    --schema <name>            Schema name (default: public)

EXAMPLES:
    # Disable RLS on table
    $SCRIPT_NAME disable-rls -U postgres --target-table users

EOF
                exit 0
                ;;
            *)
                log_error "Unknown disable-rls option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Disabling row-level security on table: $schema.$target_table"

    if execute_sql "ALTER TABLE \"$schema\".\"$target_table\" DISABLE ROW LEVEL SECURITY;" "Disable RLS"; then
        log_success "Row-level security disabled on table '$schema.$target_table'"
    else
        log_error "Failed to disable RLS on table '$schema.$target_table'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_create_policy() {
    local policy_name=""
    local target_table=""
    local schema="public"
    local command="ALL"
    local expression="true"
    local check_expression=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --policy-name)
                policy_name=$(sanitize_string "$2")
                shift 2
                ;;
            --target-table)
                target_table=$(sanitize_string "$2")
                shift 2
                ;;
            --schema)
                schema=$(sanitize_string "$2")
                shift 2
                ;;
            --command)
                command="$2"
                shift 2
                ;;
            --expression)
                expression="$2"
                shift 2
                ;;
            --check-expression)
                check_expression="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME create-policy - Create row-level security policy

USAGE:
    $SCRIPT_NAME create-policy --policy-name <name> --target-table <table> [options]

REQUIRED OPTIONS:
    --policy-name <name>        Policy name
    --target-table <table>      Table name

OPTIONAL OPTIONS:
    --schema <name>            Schema name (default: public)
    --command <cmd>            Command type: ALL, SELECT, INSERT, UPDATE, DELETE (default: ALL)
    --expression <expr>        USING expression (default: true)
    --check-expression <expr>  WITH CHECK expression

EXAMPLES:
    # Create basic policy
    $SCRIPT_NAME create-policy -U postgres --policy-name user_policy --target-table users --expression "user_id = current_user_id()"

EOF
                exit 0
                ;;
            *)
                log_error "Unknown create-policy option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$policy_name" ]]; then
        log_error "Policy name is required. Use --policy-name option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_table" ]]; then
        log_error "Target table is required. Use --target-table option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Creating RLS policy '$policy_name' on table: $schema.$target_table"

    local policy_sql="CREATE POLICY \"$policy_name\" ON \"$schema\".\"$target_table\" FOR $command USING ($expression)"

    if [[ -n "$check_expression" ]]; then
        policy_sql="$policy_sql WITH CHECK ($check_expression)"
    fi

    policy_sql="$policy_sql;"

    if execute_sql "$policy_sql" "Create RLS policy"; then
        log_success "RLS policy '$policy_name' created on table '$schema.$target_table'"
    else
        log_error "Failed to create RLS policy '$policy_name'"
        exit $EXIT_PERMISSION_ERROR
    fi
}

cmd_create_users_batch() {
    local users_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --users-file)
                users_file="$2"
                if [[ ! -f "$users_file" ]]; then
                    log_error "Users file not found: $users_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME create-users-batch - Create multiple users from file

USAGE:
    $SCRIPT_NAME create-users-batch --users-file <file> [options]

REQUIRED OPTIONS:
    --users-file <file>         JSON file containing user definitions

FILE FORMAT (JSON):
[
  {
    "username": "user1",
    "password": "pass1",
    "createdb": true,
    "login": true
  },
  {
    "username": "user2",
    "password": "pass2",
    "superuser": false
  }
]

EXAMPLES:
    # Create users from JSON file
    $SCRIPT_NAME create-users-batch -U postgres --users-file users.json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown create-users-batch option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$users_file" ]]; then
        log_error "Users file is required. Use --users-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    log_info "Creating users from batch file: $users_file"

    # Check if jq is available for JSON parsing
    if ! command -v jq &> /dev/null; then
        log_error "jq is required for JSON parsing but not installed"
        log_error "Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)"
        exit $EXIT_GENERAL_ERROR
    fi

    local users_count=$(jq '. | length' "$users_file")
    log_info "Found $users_count users to create"

    for ((i=0; i<users_count; i++)); do
        local username=$(jq -r ".[$i].username" "$users_file")
        local password=$(jq -r ".[$i].password" "$users_file")
        local createdb=$(jq -r ".[$i].createdb // false" "$users_file")
        local login=$(jq -r ".[$i].login // true" "$users_file")
        local superuser=$(jq -r ".[$i].superuser // false" "$users_file")

        validate_username "$username"

        log_info "Creating user: $username"

        # Build CREATE USER command
        local create_sql="CREATE USER \"$username\" WITH PASSWORD '$password'"

        if [[ "$superuser" == "true" ]]; then
            create_sql="$create_sql SUPERUSER"
        else
            create_sql="$create_sql NOSUPERUSER"
        fi

        if [[ "$createdb" == "true" ]]; then
            create_sql="$create_sql CREATEDB"
        else
            create_sql="$create_sql NOCREATEDB"
        fi

        if [[ "$login" == "true" ]]; then
            create_sql="$create_sql LOGIN"
        else
            create_sql="$create_sql NOLOGIN"
        fi

        create_sql="$create_sql;"

        if execute_sql "$create_sql" "Create user $username"; then
            log_success "Created user: $username"
        else
            log_error "Failed to create user: $username"
        fi
    done

    log_success "Batch user creation completed"
}

cmd_bulk_grant() {
    local users_file=""
    local target_db=""
    local privileges="SELECT"

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --users-file)
                users_file="$2"
                if [[ ! -f "$users_file" ]]; then
                    log_error "Users file not found: $users_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --target-db)
                validate_db_name "$2"
                target_db="$2"
                shift 2
                ;;
            --privileges)
                privileges="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME bulk-grant - Grant permissions to multiple users

USAGE:
    $SCRIPT_NAME bulk-grant --users-file <file> --target-db <database> [options]

REQUIRED OPTIONS:
    --users-file <file>         File containing usernames (one per line)
    --target-db <database>      Database to grant access to

OPTIONAL OPTIONS:
    --privileges <privs>        Privileges to grant (default: SELECT)

EXAMPLES:
    # Grant SELECT to all users in file
    $SCRIPT_NAME bulk-grant -U postgres --users-file users.txt --target-db myapp --privileges SELECT

EOF
                exit 0
                ;;
            *)
                log_error "Unknown bulk-grant option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$users_file" ]]; then
        log_error "Users file is required. Use --users-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$target_db" ]]; then
        log_error "Target database is required. Use --target-db option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! database_exists "$target_db"; then
        log_error "Database '$target_db' does not exist"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Granting $privileges on database '$target_db' to users from: $users_file"

    while IFS= read -r username; do
        # Skip empty lines and comments
        [[ -z "$username" || "$username" =~ ^[[:space:]]*# ]] && continue

        username=$(echo "$username" | xargs)  # Trim whitespace
        validate_username "$username"

        if ! user_exists "$username"; then
            log_warning "User '$username' does not exist, skipping"
            continue
        fi

        log_info "Granting $privileges to user: $username"

        if execute_sql "GRANT $privileges ON DATABASE \"$target_db\" TO \"$username\";" "Grant privileges to $username"; then
            log_success "Granted $privileges to user: $username"
        else
            log_error "Failed to grant privileges to user: $username"
        fi
    done < "$users_file"

    log_success "Bulk grant operation completed"
}

cmd_apply_template() {
    local template_user=""
    local users_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            -H|--host|-p|--port|-U|--username|-d|--dbname|--passwd-stdin)
                local consumed
                if consumed=$(parse_connection_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown connection option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --ssl-mode|--ssl-cert|--ssl-key|--ssl-ca)
                local consumed
                if consumed=$(parse_ssl_arguments "$1" "$2"); then
                    shift $consumed
                else
                    log_error "Unknown SSL option: $1"
                    exit $EXIT_GENERAL_ERROR
                fi
                ;;
            --template-user)
                validate_username "$2"
                template_user="$2"
                shift 2
                ;;
            --users-file)
                users_file="$2"
                if [[ ! -f "$users_file" ]]; then
                    log_error "Users file not found: $users_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME apply-template - Apply template user permissions to multiple users

USAGE:
    $SCRIPT_NAME apply-template --template-user <user> --users-file <file> [options]

REQUIRED OPTIONS:
    --template-user <username>  Template user whose permissions to copy
    --users-file <file>         File containing target usernames (one per line)

EXAMPLES:
    # Apply template permissions to multiple users
    $SCRIPT_NAME apply-template -U postgres --template-user app_template --users-file target_users.txt

EOF
                exit 0
                ;;
            *)
                log_error "Unknown apply-template option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$template_user" ]]; then
        log_error "Template username is required. Use --template-user option."
        exit $EXIT_GENERAL_ERROR
    fi

    if [[ -z "$users_file" ]]; then
        log_error "Users file is required. Use --users-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    get_database_url
    handle_password
    setup_ssl_environment
    test_database_connection

    if ! user_exists "$template_user"; then
        log_error "Template user '$template_user' does not exist"
        exit $EXIT_USER_NOT_EXISTS_ERROR
    fi

    log_info "Applying permissions from template user '$template_user' to users from: $users_file"

    while IFS= read -r username; do
        # Skip empty lines and comments
        [[ -z "$username" || "$username" =~ ^[[:space:]]*# ]] && continue

        username=$(echo "$username" | xargs)  # Trim whitespace
        validate_username "$username"

        if ! user_exists "$username"; then
            log_warning "User '$username' does not exist, skipping"
            continue
        fi

        log_info "Applying template permissions to user: $username"

        # This is a simplified implementation - in practice you'd need to
        # query all permissions from the template user and apply them
        log_info "Note: This is a basic implementation. A complete version would copy all specific permissions."

    done < "$users_file"

    log_success "Template application completed"
}

cmd_save_config() {
    local config_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            --config-file)
                config_file="$2"
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME save-config - Save current connection settings to file

USAGE:
    $SCRIPT_NAME save-config --config-file <file> [options]

REQUIRED OPTIONS:
    --config-file <file>        File to save configuration to

EXAMPLES:
    # Save current settings
    $SCRIPT_NAME save-config --config-file ~/.db-config.json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown save-config option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$config_file" ]]; then
        log_error "Config file is required. Use --config-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Saving configuration to: $config_file"

    # Create config JSON
    cat > "$config_file" << EOF
{
  "host": "${DB_HOST:-localhost}",
  "port": "${DB_PORT:-5432}",
  "username": "${DB_USERNAME:-postgres}",
  "dbname": "${DB_NAME:-postgres}",
  "ssl_mode": "${SSL_MODE:-prefer}"
}
EOF

    log_success "Configuration saved to '$config_file'"
}

cmd_load_config() {
    local config_file=""

    extract_global_options "$@"
    if [[ ${#FILTERED_ARGS[@]} -gt 0 ]]; then
        set -- "${FILTERED_ARGS[@]}"
    else
        set --
    fi

    while [[ $# -gt 0 ]]; do
        case $1 in
            --config-file)
                config_file="$2"
                if [[ ! -f "$config_file" ]]; then
                    log_error "Config file not found: $config_file"
                    exit $EXIT_GENERAL_ERROR
                fi
                shift 2
                ;;
            --help)
                cat << EOF
$SCRIPT_NAME load-config - Load connection settings from file

USAGE:
    $SCRIPT_NAME load-config --config-file <file> [options]

REQUIRED OPTIONS:
    --config-file <file>        File to load configuration from

EXAMPLES:
    # Load saved settings
    $SCRIPT_NAME load-config --config-file ~/.db-config.json

EOF
                exit 0
                ;;
            *)
                log_error "Unknown load-config option: $1"
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ -z "$config_file" ]]; then
        log_error "Config file is required. Use --config-file option."
        exit $EXIT_GENERAL_ERROR
    fi

    # Check if jq is available for JSON parsing
    if ! command -v jq &> /dev/null; then
        log_error "jq is required for JSON parsing but not installed"
        log_error "Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)"
        exit $EXIT_GENERAL_ERROR
    fi

    log_info "Loading configuration from: $config_file"

    # Load settings from JSON
    DB_HOST=$(jq -r '.host // "localhost"' "$config_file")
    export DB_HOST

    DB_PORT=$(jq -r '.port // "5432"' "$config_file")
    export DB_PORT

    DB_USERNAME=$(jq -r '.username // "postgres"' "$config_file")
    export DB_USERNAME

    DB_NAME=$(jq -r '.dbname // "postgres"' "$config_file")
    export DB_NAME

    SSL_MODE=$(jq -r '.ssl_mode // "prefer"' "$config_file")
    export SSL_MODE

    log_success "Configuration loaded from '$config_file'"
    log_info "Host: $DB_HOST, Port: $DB_PORT, User: $DB_USERNAME, Database: $DB_NAME"
}

show_version() {
    echo "$SCRIPT_NAME version $SCRIPT_VERSION"
}

# Main command dispatcher
main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit $EXIT_GENERAL_ERROR
    fi

    # Parse global options first
    while [[ $# -gt 0 ]]; do
        case $1 in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            create-user|change-password|delete-user|grant-db-access|grant-schema-access|grant-create-db|grant-sequence-access|revoke-access|show-user-permissions|copy-user-permissions|lock-user|unlock-user|reset-user|set-connection-limit|create-role|assign-role|revoke-role|list-roles|list-user-roles|list-role-members|grant-table-access|revoke-table-access|grant-function-access|grant-view-access|grant-column-access|grant-tablespace-access|rotate-password|show-user-activity|security-scan|enable-rls|disable-rls|create-policy|create-users-batch|bulk-grant|apply-template|save-config|load-config|list-users|show-active-connections|terminate-user-connections|audit-permissions|validate-permissions|backup-permissions|restore-permissions|help|version)
                break
                ;;
            *)
                log_error "Unknown global option: $1"
                show_help
                exit $EXIT_GENERAL_ERROR
                ;;
        esac
    done

    if [[ $# -eq 0 ]]; then
        log_error "No command specified"
        show_help
        exit $EXIT_GENERAL_ERROR
    fi

    local command="$1"
    shift

    # Check prerequisites
    if ! command -v psql &> /dev/null; then
        log_error "PostgreSQL client (psql) is required but not installed"
        log_error "Install with: brew install postgresql (macOS) or apt-get install postgresql-client (Ubuntu)"
        exit $EXIT_GENERAL_ERROR
    fi

    # Execute command
    case "$command" in
        create-user)
            cmd_create_user "$@"
            ;;
        change-password)
            cmd_change_password "$@"
            ;;
        delete-user)
            cmd_delete_user "$@"
            ;;
        grant-db-access)
            cmd_grant_db_access "$@"
            ;;
        grant-schema-access)
            cmd_grant_schema_access "$@"
            ;;
        grant-create-db)
            cmd_grant_create_db "$@"
            ;;
        grant-sequence-access)
            cmd_grant_sequence_access "$@"
            ;;
        revoke-access)
            cmd_revoke_access "$@"
            ;;
        show-user-permissions)
            cmd_show_user_permissions "$@"
            ;;
        copy-user-permissions)
            cmd_copy_user_permissions "$@"
            ;;
        lock-user)
            cmd_lock_user "$@"
            ;;
        unlock-user)
            cmd_unlock_user "$@"
            ;;
        reset-user)
            cmd_reset_user "$@"
            ;;
        set-connection-limit)
            cmd_set_connection_limit "$@"
            ;;
        create-role)
            cmd_create_role "$@"
            ;;
        assign-role)
            cmd_assign_role "$@"
            ;;
        list-roles)
            cmd_list_roles "$@"
            ;;
        show-active-connections)
            cmd_show_active_connections "$@"
            ;;
        terminate-user-connections)
            cmd_terminate_user_connections "$@"
            ;;
        audit-permissions)
            cmd_audit_permissions "$@"
            ;;
        validate-permissions)
            cmd_validate_permissions "$@"
            ;;
        backup-permissions)
            cmd_backup_permissions "$@"
            ;;
        restore-permissions)
            cmd_restore_permissions "$@"
            ;;
        list-users)
            cmd_list_users "$@"
            ;;
        revoke-role)
            cmd_revoke_role "$@"
            ;;
        list-user-roles)
            cmd_list_user_roles "$@"
            ;;
        list-role-members)
            cmd_list_role_members "$@"
            ;;
        grant-table-access)
            cmd_grant_table_access "$@"
            ;;
        revoke-table-access)
            cmd_revoke_table_access "$@"
            ;;
        grant-function-access)
            cmd_grant_function_access "$@"
            ;;
        grant-view-access)
            cmd_grant_view_access "$@"
            ;;
        grant-column-access)
            cmd_grant_column_access "$@"
            ;;
        grant-tablespace-access)
            cmd_grant_tablespace_access "$@"
            ;;
        rotate-password)
            cmd_rotate_password "$@"
            ;;
        show-user-activity)
            cmd_show_user_activity "$@"
            ;;
        security-scan)
            cmd_security_scan "$@"
            ;;
        enable-rls)
            cmd_enable_rls "$@"
            ;;
        disable-rls)
            cmd_disable_rls "$@"
            ;;
        create-policy)
            cmd_create_policy "$@"
            ;;
        create-users-batch)
            cmd_create_users_batch "$@"
            ;;
        bulk-grant)
            cmd_bulk_grant "$@"
            ;;
        apply-template)
            cmd_apply_template "$@"
            ;;
        save-config)
            cmd_save_config "$@"
            ;;
        load-config)
            cmd_load_config "$@"
            ;;
        help)
            show_help
            ;;
        version)
            show_version
            ;;
        *)
            log_error "Unknown command: $command"
            show_help
            exit $EXIT_GENERAL_ERROR
            ;;
    esac
}

# Execute main function
main "$@"
