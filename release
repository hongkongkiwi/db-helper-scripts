#!/bin/bash

# Database Helper Scripts Release Script
# Updates all script versions, creates tags, and pushes to repository

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

# Script variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSION_FILE="$SCRIPT_DIR/VERSION"
NEW_VERSION=""
DRY_RUN=false
FORCE=false

# Script files to update
SCRIPT_FILES=(
    "db-backup-restore"
    "db-copy"
    "db-user-manager"
)

show_help() {
    cat << EOF
Database Helper Scripts Release Tool

USAGE:
    $0 <version> [options]
    $0 --current          # Show current version
    $0 --help            # Show this help

ARGUMENTS:
    <version>            New version number (e.g., 2.1.0, 1.5.2)

OPTIONS:
    --dry-run           Show what would be done without making changes
    --force             Force release even if working directory is dirty
    --current           Show current version and exit
    -h, --help          Show this help message

EXAMPLES:
    # Release version 2.1.0
    $0 2.1.0

    # Preview what a release would do
    $0 2.1.0 --dry-run

    # Show current version
    $0 --current

EOF
}

get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        # Fallback: get version from first script
        grep 'SCRIPT_VERSION=' "$SCRIPT_DIR/db-backup-restore" | head -1 | sed 's/.*"\(.*\)".*/\1/'
    fi
}

validate_version() {
    local version="$1"
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
        log_error "Invalid version format: $version"
        log_error "Expected format: X.Y.Z or X.Y.Z-suffix (e.g., 2.1.0, 1.0.0-beta)"
        exit 1
    fi
}

check_git_status() {
    if [[ "$FORCE" == "true" ]]; then
        return 0
    fi

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        exit 1
    fi

    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        log_error "Working directory has uncommitted changes"
        log_error "Commit your changes or use --force to override"
        git status --porcelain
        exit 1
    fi

    # Check for untracked files that might be important
    local untracked_files
    untracked_files=$(git ls-files --others --exclude-standard)
    if [[ -n "$untracked_files" ]]; then
        log_warning "Untracked files found:"
        echo "$untracked_files"
        log_warning "Consider adding them or use --force to ignore"
    fi
}

update_version_file() {
    local version="$1"
    log_info "Updating VERSION file to $version"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would write '$version' to $VERSION_FILE"
        return 0
    fi

    echo "$version" > "$VERSION_FILE"
    log_success "Updated VERSION file"
}

update_script_versions() {
    local version="$1"
    log_info "Updating script versions to $version"

    for script in "${SCRIPT_FILES[@]}"; do
        local script_path="$SCRIPT_DIR/$script"

        if [[ ! -f "$script_path" ]]; then
            log_warning "Script not found: $script_path"
            continue
        fi

        log_info "Updating $script"

        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "[DRY RUN] Would update SCRIPT_VERSION in $script to $version"
            continue
        fi

        # Update the SCRIPT_VERSION line - handle both readonly and non-readonly declarations
        if grep -q "readonly SCRIPT_VERSION=" "$script_path"; then
            sed -i.bak "s/readonly SCRIPT_VERSION=\"[^\"]*\"/readonly SCRIPT_VERSION=\"$version\"/" "$script_path"
        else
            sed -i.bak "s/SCRIPT_VERSION=\"[^\"]*\"/SCRIPT_VERSION=\"$version\"/" "$script_path"
        fi

        # Remove backup file
        rm -f "${script_path}.bak"

        log_success "Updated $script"
    done
}

verify_updates() {
    local version="$1"
    log_info "Verifying version updates"

    local all_good=true

    # Check VERSION file
    if [[ "$DRY_RUN" == "false" ]]; then
        local version_file_content
        version_file_content=$(cat "$VERSION_FILE")
        if [[ "$version_file_content" != "$version" ]]; then
            log_error "VERSION file verification failed: expected '$version', got '$version_file_content'"
            all_good=false
        fi
    fi

    # Check each script
    for script in "${SCRIPT_FILES[@]}"; do
        local script_path="$SCRIPT_DIR/$script"

        if [[ ! -f "$script_path" ]]; then
            continue
        fi

        if [[ "$DRY_RUN" == "false" ]]; then
            local script_version
            script_version=$(grep 'SCRIPT_VERSION=' "$script_path" | head -1 | sed 's/.*"\(.*\)".*/\1/')
            if [[ "$script_version" != "$version" ]]; then
                log_error "Script $script verification failed: expected '$version', got '$script_version'"
                all_good=false
            fi
        fi
    done

    if [[ "$all_good" == "true" ]]; then
        log_success "Version verification passed"
        return 0
    else
        log_error "Version verification failed"
        return 1
    fi
}

create_git_tag() {
    local version="$1"
    local tag_name="v$version"

    log_info "Creating git tag: $tag_name"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would create tag: $tag_name"
        log_info "[DRY RUN] Would add and commit changes"
        log_info "[DRY RUN] Would push changes and tags"
        return 0
    fi

    # Add changed files
    git add VERSION "${SCRIPT_FILES[@]}"

    # Commit changes
    git commit -m "Release version $version

- Updated all script versions to $version
- Updated VERSION file"

    # Create annotated tag
    git tag -a "$tag_name" -m "Release version $version

Database Helper Scripts v$version

Changes:
- Updated all script versions to $version
- Centralized version management"

    log_success "Created tag: $tag_name"
}

push_changes() {
    local version="$1"

    log_info "Pushing changes and tags to remote"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY RUN] Would push commits and tags to origin"
        return 0
    fi

    # Push commits
    git push origin HEAD

    # Push tags
    git push origin "v$version"

    log_success "Pushed changes and tags to remote"
}

show_current_version() {
    local current_version
    current_version=$(get_current_version)
    echo "Current version: $current_version"

    log_info "Script versions:"
    for script in "${SCRIPT_FILES[@]}"; do
        local script_path="$SCRIPT_DIR/$script"
        if [[ -f "$script_path" ]]; then
            local script_version
            script_version=$(grep 'SCRIPT_VERSION=' "$script_path" | head -1 | sed 's/.*"\(.*\)".*/\1/')
            echo "  $script: $script_version"
        fi
    done
}

main() {
    if [[ $# -eq 0 ]]; then
        log_error "Version number required"
        show_help
        exit 1
    fi

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --current)
                show_current_version
                exit 0
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                if [[ -z "$NEW_VERSION" ]]; then
                    NEW_VERSION="$1"
                else
                    log_error "Multiple version numbers provided"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$NEW_VERSION" ]]; then
        log_error "Version number required"
        show_help
        exit 1
    fi

    # Validate inputs
    validate_version "$NEW_VERSION"

    # Show current version
    local current_version
    current_version=$(get_current_version)
    log_info "Current version: $current_version"
    log_info "New version: $NEW_VERSION"

    if [[ "$current_version" == "$NEW_VERSION" ]]; then
        log_warning "New version is the same as current version"
        if [[ "$FORCE" != "true" ]]; then
            log_error "Use --force to override"
            exit 1
        fi
    fi

    # Pre-flight checks
    check_git_status

    if [[ "$DRY_RUN" == "true" ]]; then
        log_warning "DRY RUN MODE - No changes will be made"
    fi

    log_info "Starting release process for version $NEW_VERSION"

    # Execute release steps
    update_version_file "$NEW_VERSION"
    update_script_versions "$NEW_VERSION"
    verify_updates "$NEW_VERSION"
    create_git_tag "$NEW_VERSION"
    push_changes "$NEW_VERSION"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_success "Dry run completed successfully"
        log_info "Run without --dry-run to execute the release"
    else
        log_success "Release $NEW_VERSION completed successfully!"
        log_info "Tag v$NEW_VERSION has been created and pushed"
        log_info "All scripts now use version $NEW_VERSION"
    fi
}

main "$@"
